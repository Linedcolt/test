<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Taiko Playable — BPM Grid (Revamp)</title>
  <style>
    :root{--skin:#f3d0b0;--bg:#0b0f16;--panel:#1b1b1b}
    body { margin: 0; background: var(--bg); overflow: hidden; font-family: Inter, system-ui, Arial }
    canvas { display: block; margin: auto; background: transparent; display:block }
    .judgementText {
      position: fixed; /* fixed so left/top are viewport coords */
      transform: translate(-50%, -8px);
      font-size: 28px;
      font-weight: 800;
      opacity: 0;
      pointer-events: none;
      transition: transform 0.12s ease, opacity 0.12s ease;
      text-shadow: 0 6px 18px rgba(0,0,0,0.6);
    }
    .miss { color: #ff5b5b; }
    .good { color: #ffffff; }
    .perfect { color: #ffd66b; }
    /* BPM control */
    .controls { position: fixed; left: 50%; transform: translateX(-50%); bottom: 10px; display:flex; gap:8px; align-items:center; }
    .controls button{ padding:6px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:#131316; color:#fff }
    .controls .bpm { color:#fff; font-weight:700; padding:6px 10px; }
    .controls label{color:#fff}
    /* score */
    .score { position: fixed; right: 14px; top: 10px; color: #fff; font-weight:800; font-size:18px }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="1000" height="380"></canvas>
<div id="judgement" class="judgementText"></div>
<div class="score" id="score">Score: 0</div>
<div class="controls">
  <button id="bpmDown">-</button>
  <div class="bpm" id="bpmDisplay">BPM: 120</div>
  <button id="bpmUp">+</button>
  <label style="display:flex;align-items:center;gap:6px;color:#fff"><input type="checkbox" id="autoplay">Auto</label>
</div>
<script>
// Taiko — BPM-locked note spawner (pads at bottom, touch kat support)
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// Layout
const laneY = H * 0.5;
let judgementX = 180;
const noteRadius = 28; // note radius
const strokeColor = '#000';

// Overlay placement (make background a bit wider to the left)
let overlayRight = judgementX - 60; // shift more left
const overlayLeft = -20; // slight negative to extend left
let overlayWidth = overlayRight - overlayLeft;
let drumCenterX = overlayRight - 60; // position of drum circle
let drumCenterY = laneY;
let drumR = 52;
let drumRimOuter = drumR + 24; // visible rim area

// Bottom pads (4 tappable squares)
let padHeight = 120; // bottom area height
let padCount = 4;
let padWidth = W / padCount;
let padState = [false,false,false,false]; // highlight on press

// Timing / BPM
let bpm = 120; // beats per minute (editable)
let subdivisionsPerBeat = 4; // 1/4-beat snapping
let beatMs = 60000 / bpm;
let gridMs = beatMs / subdivisionsPerBeat; // ms per grid step

// Visual timing
let speedPxPerMs = 0.45 * 1.25; // visual speed
const lookaheadMs = 8000; // schedule ahead

// Scheduling state
let scheduledNotes = []; // {beatIndex,timeMs,color,hit,judged,hitTime,vy,ay,alpha}
let lastScheduledBeatIndex = -1;
let lastGroup = [];
let lastColors = [];

// auto
let autoMode = false;
document.getElementById('autoplay').addEventListener('change', e=>{ autoMode = e.target.checked; });

// Windows (ms)
const perfectWindow = 60; // <= this => Perfect (no text)
const goodWindow = 150;   // <= this => Good
const lateWindow = 400;   // >good and <= late -> Miss if hit; >late -> auto-miss

// Group rules
const allowedGroupSizes = [1,3,5,7];

// Combo and score
let combo = 0;
let comboScale = 1; // for animated bump
let comboLastUpdated = 0;
let score = 0;

// Song clock
let startTime = null;

// background particles
const bgParticles = [];
for(let i=0;i<24;i++){
  bgParticles.push({x:Math.random()*W,y:Math.random()*H, r:10+Math.random()*40, a:0.06+Math.random()*0.12, vx:(Math.random()-0.5)*0.02, vy:(Math.random()-0.5)*0.02, ang:Math.random()*Math.PI*2});
}

// Utility
function colorForKey(key){ return (key==='f'||key==='j') ? 'red' : 'blue'; }
function drawColor(type){ return type === 'red' ? '#ff5b5b' : '#42a4f5'; }
function updateScoreDisplay(){ document.getElementById('score').textContent = 'Score: ' + Math.max(0, Math.floor(score)); }

// Constraint helpers (unchanged)
function breaksTripleHistory(last, first){ if (last.length < 2) return false; const p1 = last[last.length-1]; const p2 = last[last.length-2]; return (p1 === p2 && p1 === first); }
function isAlternating(arr){ if (arr.length < 4) return false; return (arr[0] !== arr[1] && arr[0] === arr[2] && arr[1] === arr[3]); }
function violatesBannedPatterns(arr){
  let run=1; for(let i=1;i<arr.length;i++){ if (arr[i]===arr[i-1]){ run++; if (run>=5) return true; } else run=1; }
  for(let i=0;i+4<arr.length;i++){
    const slice = arr.slice(i,i+5);
    if (slice[0]!==slice[1] && slice[0]===slice[2] && slice[1]===slice[3] && slice[2]===slice[4]) return true;
  }
  return false;
}

// Fill schedule up to lookahead — enforce exactly 1-grid gap between groups
function fillSchedule(songTime){
  const lastBeatToSchedule = Math.floor((songTime + lookaheadMs) / gridMs);
  if (lastScheduledBeatIndex < 0) lastScheduledBeatIndex = Math.floor(songTime / gridMs) - 1;
  let nextBeat = lastScheduledBeatIndex + 1;
  while (nextBeat <= lastBeatToSchedule){
    const gap = 1; // exactly 1 grid gap between groups
    const groupStart = nextBeat + gap;
    if (groupStart > lastBeatToSchedule) break;

    const groupSize = allowedGroupSizes[Math.floor(Math.random()*allowedGroupSizes.length)];
    let group = null;
    for (let attempt=0; attempt<30; attempt++){
      const cand = [];
      for (let i=0;i<groupSize;i++){
        let c = Math.random() < 0.5 ? 'red' : 'blue';
        if (breaksTripleHistory(lastColors, c)) c = (c==='red') ? 'blue' : 'red';
        cand.push(c);
      }
      if (cand.length >=2 && cand[cand.length-1] === cand[cand.length-2]) cand[cand.length-1] = cand[cand.length-1] === 'red' ? 'blue' : 'red';
      if (isAlternating(cand)) cand[cand.length-1] = cand[cand.length-1] === 'red' ? 'blue' : 'red';
      if (lastGroup.length > 0){
        const prev = lastGroup;
        const prevEndsSingle = prev.length >= 2 ? (prev[prev.length-1] !== prev[prev.length-2]) : true;
        if (prevEndsSingle && cand.length > 1){
          const lastColor = prev[prev.length-1];
          if (cand[0] === lastColor && cand[1] !== lastColor){ cand[0] = (lastColor === 'red') ? 'blue' : 'red'; }
        }
      }
      const combined = lastColors.slice(-2).concat(cand.slice(0,2));
      if (combined.length >=3 && combined.slice(-3).every(x => x===combined[combined.length-1])) continue;
      if (violatesBannedPatterns(cand)) continue;
      group = cand; break;
    }
    if (!group) group = ['red'];

    for (let i=0;i<group.length;i++){
      const beatIndex = groupStart + i;
      const timeMs = beatIndex * gridMs;
      scheduledNotes.push({beatIndex, timeMs, color: group[i], hit:false, judged:false, hitTime:null, vy:0, ay:0.0012, alpha:1});
      lastScheduledBeatIndex = beatIndex;
    }

    lastGroup = group.slice();
    lastColors = lastColors.concat(group);
    if (lastColors.length > 32) lastColors = lastColors.slice(-32);

    nextBeat = lastScheduledBeatIndex + 1;
  }
}

function noteXAtTime(noteTimeMs, songTime){ return judgementX + (noteTimeMs - songTime) * speedPxPerMs; }

// Draw background
function drawBackground(dt){
  ctx.save();
  for(const p of bgParticles){
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.ang += 0.0003 * dt;
    if (p.x < -200) p.x = W + 200; if (p.x > W + 200) p.x = -200;
    if (p.y < -200) p.y = H + 200; if (p.y > H + 200) p.y = -200;
    ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.ang);
    ctx.globalAlpha = p.a;
    ctx.fillStyle = 'rgba(80,120,160,0.08)'; ctx.beginPath(); ctx.ellipse(0,0,p.r*1.6,p.r,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  ctx.restore();
}

// Draw lane
function drawLane(){
  const laneWidth = W - 80;
  const x = 40; const y = laneY - 64; const h = 128; const r = 12;
  ctx.save(); ctx.fillStyle = 'rgba(255,255,255,0.02)'; roundRect(ctx, x, y, laneWidth, h, r, true, false);
  ctx.fillStyle = 'rgba(255,255,255,0.03)'; roundRect(ctx, x+6, y+12, laneWidth-12, h-24, r-6, true, false);
  ctx.restore();
}
function roundRect(ctx, x, y, w, h, r, fill, stroke){ if (r===undefined) r=5; ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r); ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); ctx.closePath(); if (fill) ctx.fill(); if (stroke) ctx.stroke(); }

// Draw overlay and drum
function drawOverlay(){
  const laneH = 128; const laneYTop = laneY - laneH/2;
  ctx.fillStyle = '#101214'; ctx.fillRect(overlayLeft, laneYTop, overlayWidth + 20, laneH);
  ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(drumCenterX, drumCenterY, drumR+10, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--skin') || '#f3d0b0'; ctx.arc(drumCenterX, drumCenterY, drumR+4, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.fillStyle = '#11131a'; ctx.arc(drumCenterX, drumCenterY, drumR, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(drumCenterX-drumR, drumCenterY); ctx.lineTo(drumCenterX+drumR, drumCenterY); ctx.stroke();

  // visible rim guides to show where kats register
  ctx.beginPath(); ctx.strokeStyle = 'rgba(66,164,245,0.12)'; ctx.lineWidth = 10; ctx.arc(drumCenterX, drumCenterY, drumRimOuter, 0, Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.strokeStyle = 'rgba(255,90,90,0.12)'; ctx.lineWidth = 8; ctx.arc(drumCenterX, drumCenterY, drumR + 2, 0, Math.PI*2); ctx.stroke();

  // show four pressable zones visually when active
  if (overlayState.leftSurface) { ctx.beginPath(); ctx.fillStyle = 'rgba(255,100,100,0.95)'; ctx.moveTo(drumCenterX,drumCenterY); ctx.arc(drumCenterX, drumCenterY, drumR-2, Math.PI*0.5, Math.PI*1.5); ctx.closePath(); ctx.fill(); }
  if (overlayState.leftRim) { ctx.beginPath(); ctx.strokeStyle = 'rgba(120,190,255,0.95)'; ctx.lineWidth = 8; ctx.arc(drumCenterX, drumCenterY, drumR+6, Math.PI*0.5, Math.PI*1.5); ctx.stroke(); }
  if (overlayState.rightSurface) { ctx.beginPath(); ctx.fillStyle = 'rgba(255,100,100,0.95)'; ctx.moveTo(drumCenterX,drumCenterY); ctx.arc(drumCenterX, drumCenterY, drumR-2, Math.PI*1.5, Math.PI*0.5); ctx.closePath(); ctx.fill(); }
  if (overlayState.rightRim) { ctx.beginPath(); ctx.strokeStyle = 'rgba(120,190,255,0.95)'; ctx.lineWidth = 8; ctx.arc(drumCenterX, drumCenterY, drumR+6, Math.PI*1.5, Math.PI*0.5); ctx.stroke(); }

  // rectangle character above drum: depressed on miss, vibe on correct
  const rectW = 70, rectH = 24; const rectX = drumCenterX - rectW/2, rectY = drumCenterY - drumR - 40;
  ctx.save();
  let yOffset = 0; let s = 1;
  if (overlayRect.depressed){ yOffset = 6; }
  if (overlayRect.vibeScale > 1){ s = overlayRect.vibeScale; }
  ctx.translate(drumCenterX, rectY + yOffset); ctx.scale(1, s); ctx.translate(-drumCenterX, -(rectY + yOffset));
  ctx.fillStyle = overlayRect.depressed ? '#4b1b1b' : '#222'; ctx.fillRect(rectX, rectY, rectW, rectH);
  ctx.strokeStyle = '#444'; ctx.strokeRect(rectX, rectY, rectW, rectH);
  ctx.restore();

  // combo indicator — centered vertically on drum, larger number, no label
  ctx.textAlign = 'center'; ctx.fillStyle = '#ffd'; ctx.font = `${28 * comboScale}px Inter, system-ui`; ctx.fillText(combo.toString(), drumCenterX, drumCenterY + 10);
}

// overlay visual state
const overlayState = {leftSurface:false, leftRim:false, rightSurface:false, rightRim:false};
const overlayRect = {depressed:false, vibeScale:1, lastVibe:0};
function pressOverlay(side){
  if (side === 'don-left'){ overlayState.leftSurface = true; setTimeout(()=> overlayState.leftSurface=false, 140); }
  if (side === 'ka-left'){ overlayState.leftRim = true; setTimeout(()=> overlayState.leftRim=false, 140); }
  if (side === 'don-right'){ overlayState.rightSurface = true; setTimeout(()=> overlayState.rightSurface=false, 140); }
  if (side === 'ka-right'){ overlayState.rightRim = true; setTimeout(()=> overlayState.rightRim=false, 140); }
}
function triggerRectOnMiss(){ overlayRect.depressed = true; setTimeout(()=> overlayRect.depressed=false, 220); }
function triggerRectOnHit(){ overlayRect.vibeScale = 1.18; overlayRect.lastVibe = performance.now(); }

// Draw bottom pads (4 squares)
function drawBottomPads(){
  padWidth = W / padCount;
  const y = H - padHeight;
  for(let i=0;i<padCount;i++){
    const x = i * padWidth;
    ctx.save();
    ctx.fillStyle = padState[i] ? 'rgba(255,255,255,0.12)' : 'rgba(255,255,255,0.06)';
    ctx.fillRect(x, y, padWidth-1, padHeight);
    // subtle border
    ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.strokeRect(x, y, padWidth-1, padHeight);
    ctx.restore();
  }
}

// Draw barlines
function drawBarlines(songTime){
  const subdivisionsPerBar = subdivisionsPerBeat * 4; // 4/4
  const firstBeatIndex = Math.floor(songTime / gridMs);
  const lastBeatIndex = Math.floor((songTime + lookaheadMs) / gridMs);
  ctx.save(); ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1;
  for (let bi = firstBeatIndex; bi <= lastBeatIndex; bi++){
    if (bi % subdivisionsPerBar === 0){ const x = noteXAtTime(bi * gridMs, songTime); ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
  }
  ctx.restore();
}

// draw notes
function drawNotes(songTime){
  const visible = scheduledNotes.filter(n => n.timeMs - songTime <= lookaheadMs && (songTime - n.timeMs) < lookaheadMs);
  visible.sort((a,b) => b.timeMs - a.timeMs).forEach(n => {
    const x = noteXAtTime(n.timeMs, songTime);
    let y = laneY; let alpha = n.alpha ?? 1;
    if (n.hit && n.hitTime != null){
      const t = (songTime - n.hitTime);
      const vy0 = n.vy || -0.35; const ay = n.ay || 0.0012;
      y = laneY + vy0 * t + 0.5 * ay * t * t;
      if (x < 140){ alpha = Math.max(0, (x - 20) / 120); }
      n.alpha = alpha;
      if (t > 1200) { n.judged = true; }
    }
    if (n.judged) return;
    if (x < -100 || x > W + 100) return;
    ctx.save(); ctx.globalAlpha = alpha;
    const coreR = noteRadius - 8;
    const skinStroke = 4;
    const blackStroke = 4;
    ctx.beginPath(); ctx.fillStyle = drawColor(n.color); ctx.arc(x, y, coreR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.lineWidth = skinStroke; ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--skin') || '#f3d0b0'; ctx.arc(x, y, coreR + skinStroke/2 + 1, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.lineWidth = blackStroke; ctx.strokeStyle = strokeColor; ctx.arc(x, y, coreR + skinStroke/2 + 1 + blackStroke/2 + 1, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  });
}

// show judgement text above circle
function showJudgement(type){
  if (type === 'perfect') return; // perfect shows no text
  const el = document.getElementById('judgement');
  const rect = canvas.getBoundingClientRect();
  const left = rect.left + judgementX;
  el.style.left = left + 'px';
  el.className = 'judgementText ' + type;
  el.innerText = type === 'miss' ? 'Miss' : 'Good';
  el.style.top = (rect.top + laneY - noteRadius - 40) + 'px';
  el.style.opacity = 1;
  el.style.transform = 'translate(-50%, 0px)';
  setTimeout(()=>{ el.style.opacity = 0; el.style.transform = 'translate(-50%, -8px)'; }, 400);
}

// try hit nearest
function tryHit(key, songTime){
  let candidate = null; let bestDt = Infinity;
  for (const n of scheduledNotes){
    if (n.judged) continue;
    const dt = Math.abs(n.timeMs - songTime);
    if (dt < bestDt && dt <= lateWindow) { candidate = n; bestDt = dt; }
  }
  if (!candidate){ showJudgement('miss'); combo = 0; score = Math.max(0, score - 20); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); return; }
  const keyColor = colorForKey(key);
  if (keyColor !== candidate.color){ candidate.judged = true; candidate.hit = true; showJudgement('miss'); combo = 0; score = Math.max(0, score - 50); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); return; }
  if (bestDt <= perfectWindow){ combo += 1; score += 300; updateScoreDisplay(); animateCombo(); triggerRectOnHit(); candidate.hit = true; candidate.judged = false; candidate.hitTime = songTime; candidate.vy = -0.35; candidate.ay = 0.0012; candidate.alpha = 1; return; }
  if (bestDt <= goodWindow){ showJudgement('good'); combo += 1; score += 100; updateScoreDisplay(); animateCombo(); triggerRectOnHit(); candidate.hit = true; candidate.judged = false; candidate.hitTime = songTime; candidate.vy = -0.25; candidate.ay = 0.0012; candidate.alpha = 1; return; }
  candidate.judged = true; candidate.hit = true; showJudgement('miss'); combo = 0; score = Math.max(0, score - 50); updateScoreDisplay(); animateCombo(); triggerRectOnMiss();
}

function animateCombo(){ comboScale = 1.28; comboLastUpdated = performance.now(); }

// input visual mapping
function handleKeyPressVisual(k){ if (k === 'f') pressOverlay('don-left'); if (k === 'd') pressOverlay('ka-left'); if (k === 'j') pressOverlay('don-right'); if (k === 'k') pressOverlay('ka-right'); }

document.addEventListener('keydown', e => {
  const k = e.key.toLowerCase();
  if (!(['f','j','d','k'].includes(k))) return;
  handleKeyPressVisual(k);
  if (startTime != null){ const songTime = performance.now() - startTime; tryHit(k, songTime); }
});

// bottom pads input handling: D, F | J, K  (left->right: D, F, J, K)
canvas.addEventListener('pointerdown', e => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left; const y = e.clientY - rect.top;
  if (y >= H - padHeight){
    const col = Math.floor(x / padWidth);
    // clamp
    const idx = Math.max(0, Math.min(padCount-1, col));
    padState[idx] = true; setTimeout(()=> padState[idx] = false, 120);
    // mapping: 0->d,1->f,2->j,3->k
    const keyMap = ['d','f','j','k'];
    const key = keyMap[idx];
    handleKeyPressVisual(key);
    if (startTime != null) tryHit(key, performance.now() - startTime);
  } else {
    // clicking on drum overlay area left of judgement
    if (x < overlayLeft + overlayWidth){
      const dx = x - drumCenterX, dy = y - drumCenterY; const r = Math.sqrt(dx*dx + dy*dy);
      if (r <= drumR * 0.85){ // surface
        if (dx < 0){ pressOverlay('don-left'); if (startTime != null) tryHit('f', performance.now() - startTime); }
        else { pressOverlay('don-right'); if (startTime != null) tryHit('k', performance.now() - startTime); }
      } else if (r <= drumRimOuter){ // rim (kat)
        if (dx < 0){ pressOverlay('ka-left'); if (startTime != null) tryHit('d', performance.now() - startTime); }
        else { pressOverlay('ka-right'); if (startTime != null) tryHit('k', performance.now() - startTime); }
      }
    }
  }
});

// Auto play: improved to hit stacked notes — hit repeatedly while there are notes within window
function autoTick(songTime){
  if (!autoMode) return;
  // try to find and hit the closest note repeatedly until none in perfectWindow
  while(true){
    let best = null; let bestDt = Infinity;
    for (const n of scheduledNotes){ if (n.judged || n.hit) continue; const dt = Math.abs(n.timeMs - songTime); if (dt < bestDt){ best = n; bestDt = dt; } }
    if (!best) break;
    if (bestDt <= perfectWindow){ const key = (best.color === 'red') ? 'f' : 'k'; tryHit(key, songTime); continue; }
    // if closest is within good window, hit it too
    if (bestDt <= goodWindow){ const key = (best.color === 'red') ? 'f' : 'k'; tryHit(key, songTime); continue; }
    break;
  }
}

// BPM controls
const bpmDisplay = document.getElementById('bpmDisplay');
function setBPM(newBPM){ bpm = Math.max(30, Math.min(300, newBPM)); bpmDisplay.textContent = 'BPM: ' + bpm; beatMs = 60000 / bpm; gridMs = beatMs / subdivisionsPerBeat; // reset schedule
  scheduledNotes = []; lastScheduledBeatIndex = -1; lastColors = []; lastGroup = []; startTime = performance.now(); score = 0; combo = 0; updateScoreDisplay(); }
document.getElementById('bpmUp').addEventListener('click', ()=> setBPM(bpm+5));
document.getElementById('bpmDown').addEventListener('click', ()=> setBPM(bpm-5));

// main loop
let lastTs = performance.now();
function gameLoop(ts){
  if (!startTime) startTime = ts;
  const songTime = ts - startTime;
  const dt = ts - lastTs; lastTs = ts;
  fillSchedule(songTime);
  autoTick(songTime);
  if (comboScale > 1){ const elapsed = performance.now() - comboLastUpdated; comboScale = Math.max(1, 1 + (comboScale - 1) * Math.max(0, 1 - elapsed / 200)); }
  if (overlayRect.vibeScale > 1){ const ev = performance.now() - overlayRect.lastVibe; overlayRect.vibeScale = Math.max(1, 1 + (overlayRect.vibeScale - 1) * Math.max(0, 1 - ev / 200)); }
  ctx.clearRect(0,0,W,H);
  drawBackground(dt);
  drawLane();
  drawBarlines(songTime);
  // judgement circle behind notes
  ctx.save(); ctx.strokeStyle = 'rgba(200,200,200,0.5)'; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(judgementX, laneY, noteRadius + 10, 0, Math.PI*2); ctx.stroke(); ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(judgementX, laneY, noteRadius, 0, Math.PI*2); ctx.stroke(); ctx.restore();
  drawNotes(songTime);
  drawOverlay();
  drawBottomPads();
  // auto-miss
  for (const n of scheduledNotes){ if (!n.judged && !n.hit && (songTime - n.timeMs) > lateWindow){ n.judged = true; n.hit = true; combo = 0; score = Math.max(0, score - 50); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); showJudgement('miss'); } }
  scheduledNotes = scheduledNotes.filter(n => {
    if (n.judged) return false;
    if (n.hit && n.hitTime != null && (songTime - n.hitTime) > 1200) return false;
    if ((songTime - n.timeMs) > lookaheadMs) return false;
    return true;
  });
  requestAnimationFrame(gameLoop);
}

// resize handling
window.addEventListener('resize', ()=>{ W = canvas.width = canvas.clientWidth || 1000; H = canvas.height = canvas.clientHeight || 380; overlayRight = judgementX - 60; overlayWidth = overlayRight - overlayLeft; padWidth = W / padCount; semiCenterX = W/2; semiRadius = W * 0.6; drumCenterX = overlayRight - 60; drumRimOuter = drumR + 24; drumCenterY = laneY; drumR = Math.max(40, Math.min(80, Math.round(W*0.052))); padHeight = Math.max(96, Math.round(H*0.22)); });

updateScoreDisplay();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
