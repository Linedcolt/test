<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Taiko Playable — Final Iteration</title>
  <style>
    :root{--skin:#f3d0b0;--bg:#0b0f16;--panel:#1b1b1b}
    body { margin: 0; background: var(--bg); overflow: hidden; font-family: 'Nunito', 'Arial Rounded MT Bold', Inter, system-ui, Arial; padding-top: 54px; /* for header bar */ }
    canvas { display: block; margin: auto; background: transparent; touch-action: none; }
    .judgementText { position: fixed; transform: translate(-50%, -8px); font-size: 28px; font-weight: 800; opacity: 0; pointer-events: none; transition: transform 0.12s ease, opacity 0.12s ease; text-shadow: 0 6px 18px rgba(0,0,0,0.6); font-family: 'Nunito', 'Arial Rounded MT Bold', Inter, system-ui, Arial }
    .score { position: fixed; right: 14px; top: 10px; color: #fff; font-weight:800; font-size:18px; font-family: 'Nunito', 'Arial Rounded MT Bold', Inter, system-ui, Arial }
    .controls { position: fixed; left: 50%; transform: translateX(-50%); bottom: 10px; display:flex; gap:8px; align-items:center; }
    .controls button{ padding:6px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:#131316; color:#fff }
    .controls .bpm { color:#fff; font-weight:700; padding:6px 10px; font-family: 'Nunito' }
    /* song select overlay */
    .song-select-overlay{ position: fixed; inset: 0; background: rgba(6,8,10,0.8); display: none; align-items: stretch; justify-content: center; z-index: 2000; }
    .song-select-panel{ width: min(1100px, 96%); height: 86%; background: linear-gradient(180deg, rgba(22,22,22,0.98), rgba(14,14,14,0.96)); border-radius: 12px; padding: 16px; display:flex; gap:12px; box-shadow: 0 20px 60px rgba(0,0,0,0.6); }
    .song-list{ width: 46%; overflow:auto; padding:8px; background: rgba(255,255,255,0.02); border-radius:8px }
    .song-preview{ flex:1; overflow:auto; padding:8px; background: rgba(255,255,255,0.02); border-radius:8px; display:flex; flex-direction:column }
    .song-item{ padding:8px; border-radius:6px; margin-bottom:8px; cursor:pointer; display:flex; gap:8px; align-items:center }
    .song-item:hover{ background: rgba(255,255,255,0.02) }
    .song-thumb{ width:72px; height:48px; background:#111; border-radius:4px; flex-shrink:0 }
    .song-meta{ color:#ddd; font-size:13px }
    .song-title{ font-weight:700; color:#fff }
    .song-btn{ padding:8px 10px; border-radius:6px; background:#17202a; border:1px solid rgba(255,255,255,0.04); color:#fff; cursor:pointer }
    .song-controls{ display:flex; gap:8px; align-items:center; margin-bottom:8px }
    .uploader { position: fixed; left: 10px; top: 10px; font-size: 14px; color:#fff }
    /* --- Modern header bar --- */
    .header-bar {
      position: fixed;
      top: 0; left: 0; right: 0;
      height: 54px;
      background: linear-gradient(90deg, #181a22 60%, #232b3a 100%);
      display: flex;
      align-items: center;
      gap: 18px;
      padding: 0 24px;
      z-index: 100;
      box-shadow: 0 2px 16px #0006;
      border-bottom: 1px solid #232b3a;
    }
    .header-bar .logo {
      font-size: 1.35rem;
      font-weight: 900;
      color: #fff;
      letter-spacing: 1px;
      margin-right: 18px;
      user-select: none;
      text-shadow: 0 2px 12px #000a;
    }
    .header-bar .header-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .header-bar input[type="file"] {
      display: none;
    }
    .header-bar label[for="oszFile"] {
      background: #232b3a;
      color: #fff;
      padding: 7px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      border: 1px solid rgba(255,255,255,0.06);
      margin-right: 0;
      transition: background 0.12s;
    }
    .header-bar label[for="oszFile"]:hover {
      background: #2e3a4a;
    }
    .header-bar .song-btn, .header-bar button {
      font-size: 14px;
      padding: 7px 14px;
      margin: 0;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.06);
      background: #232b3a;
      color: #fff;
      cursor: pointer;
      transition: background 0.12s;
    }
    .header-bar .song-btn:hover, .header-bar button:hover {
      background: #2e3a4a;
    }
    .header-bar #chartInfo {
      color: #fff;
      font-size: 14px;
      margin-left: 18px;
      opacity: 0.85;
      font-weight: 600;
      letter-spacing: 0.2px;
      text-shadow: 0 1px 6px #000a;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
</head>
<body>
<!-- Modern header bar -->
<div class="header-bar">
  <div class="logo">Taiko Playable</div>
  <div class="header-group">
    <label for="oszFile">Load OSZ</label>
    <input id="oszFile" type="file" accept=".osz,.zip">
    <button id="loadOSZ" class="song-btn">Import</button>
    <button id="openSongSelect" class="song-btn">Song Select</button>
    <button id="playBtn" class="song-btn">Play</button>
  </div>
  <span id="chartInfo"></span>
</div>
<canvas id="gameCanvas" width="1000" height="520"></canvas>
<div id="judgement" class="judgementText"></div>
<div class="score" id="score">Score: 0</div>
<div class="song-select-overlay" id="songSelectOverlay">
  <div class="song-select-panel">
    <div class="song-list">
      <div style="display:flex;gap:8px;margin-bottom:8px">
        <input id="ssQuery" placeholder="Search maps (artist / title / creator)" style="flex:1;padding:8px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:#fff">
        <button id="ssSearch" class="song-btn">Search</button>
        <button id="ssClose" class="song-btn">Close</button>
      </div>
      <div id="ssResults"></div>
    </div>
    <div class="song-preview">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="display:flex;gap:12px;align-items:center">
          <div id="previewThumb" class="song-thumb"></div>
          <div>
            <div id="previewTitle" class="song-title">No selection</div>
            <div id="previewMeta" class="song-meta">Select a map to preview</div>
          </div>
        </div>
        <div style="display:flex;gap:8px">
          <button id="btnDownloadMap" class="song-btn">Download Map</button>
          <button id="btnLoadMap" class="song-btn">Load into game</button>
        </div>
      </div>
      <div style="flex:1;margin-top:12px;display:flex;flex-direction:column">
        <div id="bgPreviewContainer" style="flex:1;border-radius:8px;overflow:hidden;background:#0c0c0f;display:flex;align-items:center;justify-content:center;color:#888">Background preview</div>
        <div style="margin-top:8px;color:#bbb;font-size:13px">Tip: click a map on the left, then Download Map to fetch the .osz from Nerinyan. After download, click "Load into game" to load it.</div>
      </div>
    </div>
  </div>
</div>
<div class="controls">
  <button id="bpmDown">-</button>
  <div class="bpm" id="bpmDisplay">BPM: 120</div>
  <button id="bpmUp">+</button>
  <label style="display:flex;align-items:center;gap:6px;color:#fff"><input type="checkbox" id="autoplay">Auto</label>
</div>
<!-- Pause menu overlay -->
<div id="pauseOverlay" style="display:none;position:fixed;inset:0;z-index:3000;background:rgba(10,12,16,0.88);align-items:center;justify-content:center;flex-direction:column;">
  <div style="background:#181a22;padding:32px 48px;border-radius:14px;box-shadow:0 8px 32px #000a;display:flex;flex-direction:column;align-items:center;gap:18px;min-width:260px;">
    <div style="font-size:2rem;font-weight:800;color:#fff;margin-bottom:10px;">Paused</div>
    <button id="pauseContinue" class="song-btn" style="width:160px;">Continue</button>
    <button id="pauseRestart" class="song-btn" style="width:160px;">Restart</button>
    <button id="pauseQuit" class="song-btn" style="width:160px;">Quit</button>
  </div>
</div>
<script>
// Taiko Playable — fixes: key-press glow, touch miss suppression, hit sounds, single-note cooldown

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;
const laneY = H * 0.45;
let judgementX = 180;
const noteRadius = 28;
const strokeColor = '#000';
const laneH = 128; // note lane height used in several places

// Overlay placement
let overlayRight = judgementX - 60;
const overlayLeft = -20;
let overlayWidth = overlayRight - overlayLeft;
let drumCenterX = overlayRight - 60;
let drumCenterY = laneY;
let drumR = 52;
let drumRimOuter = drumR + 24;

// Bottom pads
let padHeight = 120;
let padCount = 4;
let padWidth = W / padCount;
let padState = [false,false,false,false];

// Timing / BPM
let bpm = -1; // set default BPM to -1 (disables note generation)
let subdivisionsPerBeat = 4;
let beatMs = 60000 / (bpm || 1);
let gridMs = beatMs / subdivisionsPerBeat;
let speedPxPerMs = 0.45 * 1.25;
const lookaheadMs = 8000;

// Scheduling
let scheduledNotes = []; // {beatIndex,timeMs,color,hit,judged,hitTime,vy,ay,alpha,isBig}
let lastScheduledBeatIndex = -1;
let lastGroup = [];
let lastColors = [];
let flyingNotes = []; // will hold notes that are in the "flying" (post-hit) state to draw above overlay

// Autoplay
let autoMode = false; document.getElementById('autoplay').addEventListener('change', e=>{ autoMode = e.target.checked; });
let autoLeftTurn = true; // alternating turn for autoplay

// Judgement windows
const perfectWindow = 25; // ms
const goodWindow = 60;    // ms
const lateWindow = 120;   // ms

// Group size weights (reduce single-note frequency)
let groupWeights = [ {size:1, w:8}, {size:3, w:36}, {size:5, w:36}, {size:7, w:20} ];
let singleCooldown = 0; // frames where single-note is discouraged
function pickGroupSize(){ // dynamically reduce single if recently used
  let weights = groupWeights.map(g=>({size:g.size,w:g.w}));
  if(lastGroup.length===1 || singleCooldown>0){ // reduce single chance
    const g = weights.find(x=>x.size===1); if(g) g.w = Math.max(1, Math.floor(g.w * 0.15));
  }
  const total = weights.reduce((s,o)=>s+o.w,0); let r=Math.random()*total; for(const p of weights){ r-=p.w; if(r<=0) return p.size; } return 3; }

// Combo/score
let combo = 0; let comboScale = 1; let comboLastUpdated = 0; let score = 0;
function updateScoreDisplay(){ document.getElementById('score').textContent = 'Score: ' + Math.max(0, Math.floor(score)); }

// Song clock
let startTime = null;

// background particles
const bgParticles = [];
for(let i=0;i<28;i++) bgParticles.push({x:Math.random()*W,y:Math.random()*H, r:8+Math.random()*60, a:0.04+Math.random()*0.12, vx:(Math.random()-0.5)*0.02, vy:(Math.random()-0.5)*0.02, ang:Math.random()*Math.PI*2});

// helper color/key
function colorForKey(key){ return (key==='f'||key==='j') ? 'red' : 'blue'; }
function drawColor(type){ return type === 'red' ? '#ff5b5b' : '#42a4f5'; }

// keep last key press times to detect two-handed hits
const lastKeyTimes = {f:0,d:0,j:0,k:0};
document.addEventListener('keydown', e=>{ const k = e.key.toLowerCase(); if (['f','d','j','k'].includes(k)) lastKeyTimes[k] = performance.now(); });

// Banned patterns
const bannedPatterns = new Set(['DKKKK','KDDDD','DKDKK','KDKDD','DDDKDDK','KDKKK','KDKDD','DDKDDK']);
function groupToDK(group){ return group.map(c => c==='red' ? 'D' : 'K').join(''); }
function violatesBannedSeq(seqArray){ const s = groupToDK(seqArray); for(const p of bannedPatterns){ if(s.indexOf(p) !== -1) return true; } return false; }

// overlay glow for drum hits (detailed shape on skin circle)
let overlayGlow = {type:null, side:null, ts:0, dur:320};
function triggerOverlayGlow(info){ overlayGlow.type = info.type; overlayGlow.side = info.side; overlayGlow.ts = performance.now(); }

// --- audio (simple percussive hits via WebAudio) ---
const AudioContextClass = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){ if(audioCtx) return; audioCtx = new AudioContextClass(); }
function playHitSound(type, isBig, bothHands){ ensureAudio(); const t = audioCtx.currentTime; // create a percussive envelope
  const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); if(type==='don'){ osc.type='sine'; osc.frequency.setValueAtTime(isBig?180:260, t); } else { osc.type='triangle'; osc.frequency.setValueAtTime(isBig?480:360, t); }
  gain.gain.setValueAtTime(0.0001,t);
  gain.gain.exponentialRampToValueAtTime(isBig?0.8:0.65, t+0.002);
  gain.gain.exponentialRampToValueAtTime(0.001, t+0.15);
  osc.connect(gain); gain.connect(audioCtx.destination);
  osc.start(t); osc.stop(t+0.18);
  // small click/noise for rim if not don
  if(type==='ka'){ const bufferSize=audioCtx.sampleRate*0.02; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); const data = buffer.getChannelData(0); for(let i=0;i<bufferSize;i++){ data[i] = (Math.random()*2-1) * Math.exp(-i/(bufferSize*0.02)); } const noise = audioCtx.createBufferSource(); noise.buffer = buffer; const ng = audioCtx.createGain(); ng.gain.setValueAtTime(0.6, t); ng.gain.exponentialRampToValueAtTime(0.001, t+0.08); noise.connect(ng); ng.connect(audioCtx.destination); noise.start(t); noise.stop(t+0.08); }
}

// fill schedule with 25% chance big for single-note groups (but weighted group size pick)
function fillSchedule(songTime){
  // Prevent note generation if bpm is -1 (disabled)
  if (bpm === -1) return;
  const lastBeatToSchedule = Math.floor((songTime + lookaheadMs) / gridMs); if (lastScheduledBeatIndex < 0) lastScheduledBeatIndex = Math.floor(songTime / gridMs) - 1; let nextBeat = lastScheduledBeatIndex + 1; while(nextBeat <= lastBeatToSchedule){ const gap = 1; const groupStart = nextBeat + gap; if (groupStart > lastBeatToSchedule) break; const groupSize = pickGroupSize(); let group = null; for(let attempt=0; attempt<120; attempt++){ const cand = []; for(let i=0;i<groupSize;i++){ let c = Math.random()<0.5 ? 'red' : 'blue'; if (lastColors.length>=2 && lastColors[lastColors.length-1]===lastColors[lastColors.length-2] && lastColors[lastColors.length-1]===c) c = c==='red'? 'blue' : 'red'; cand.push(c); } if (cand.length>=2 && cand[cand.length-1]===cand[cand.length-2]) cand[cand.length-1] = cand[cand.length-1] === 'red' ? 'blue' : 'red'; if (cand.length>=4 && cand[0]!==cand[1] && cand[0]===cand[2] && cand[1]===cand[3]) cand[cand.length-1] = cand[cand.length-1] === 'red' ? 'blue' : 'red'; if (lastGroup.length>0){ const prev=lastGroup; const prevEndsSingle = prev.length>=2 ? (prev[prev.length-1] !== prev[prev.length-2]) : true; if (prevEndsSingle && cand.length>1){ const lastColor = prev[prev.length-1]; if (cand[0]===lastColor && cand[1]!==lastColor) cand[0] = lastColor==='red' ? 'blue' : 'red'; } }
      // don't repeat the exact previous group
      if(lastGroup.length>0 && cand.join('') === lastGroup.join('')) continue;
      const combined = lastColors.slice(-8).concat(cand);
      if (combined.length>=3 && combined.slice(-3).every(x=>x===combined[combined.length-1])) continue;
      if (violatesBannedSeq(combined)) continue;
      group=cand; break; } if(!group) group=['red']; for(let i=0;i<group.length;i++){ const beatIndex = groupStart + i; const timeMs = beatIndex * gridMs; const isBig = (group.length===1 && Math.random() < 0.25); scheduledNotes.push({beatIndex,timeMs,color:group[i],hit:false,judged:false,hitTime:null,vy:0,ay:0.0014,alpha:1,isBig:isBig}); lastScheduledBeatIndex = beatIndex; } lastGroup = group.slice(); lastColors = lastColors.concat(group); if (lastColors.length>64) lastColors = lastColors.slice(-64); // if we scheduled a single, impose a short cooldown to avoid bursts
    if(lastGroup.length===1) singleCooldown = 4; nextBeat = lastScheduledBeatIndex + 1; } }

function noteXAtTime(noteTimeMs, songTime){ return judgementX + (noteTimeMs - songTime) * speedPxPerMs; }

// drawing helpers
function roundRect(ctx,x,y,w,h,r,fill){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill) ctx.fill(); }

// draw background
function drawBackground(dt){ ctx.save(); for(const p of bgParticles){ p.x += p.vx * dt; p.y += p.vy * dt; p.ang += 0.0003 * dt; if(p.x<-300) p.x=W+300; if(p.x>W+300) p.x=-300; if(p.y<-300) p.y=H+300; if(p.y>H+300) p.y=-300; ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.ang); ctx.globalAlpha = p.a; ctx.fillStyle='rgba(120,160,200,0.07)'; ctx.beginPath(); ctx.ellipse(0,0,p.r*1.6,p.r,0,0,Math.PI*2); ctx.fill(); ctx.restore(); } ctx.restore(); }

// draw lane
function drawLane(){ const laneWidth = W - 80; const x=40,y=laneY-laneH/2,h=laneH,r=12; ctx.save(); ctx.fillStyle='rgba(255,255,255,0.02)'; roundRect(ctx,x,y,laneWidth,h,r,true); ctx.fillStyle='rgba(255,255,255,0.03)'; roundRect(ctx,x+6,y+12,laneWidth-12,h-24,r-6,true); ctx.restore(); }

// draw overlay drum (with the new double-layer + vertical split glow placed on skin)
function drawOverlay(){ const laneYTop=laneY-laneH/2; ctx.fillStyle='#101214'; ctx.fillRect(overlayLeft,laneYTop,overlayWidth+20,laneH);
 // glow (if active) - draw double-layer circle and vertical split anchored to skin circle radius
 const now = performance.now(); const glowElapsed = now - overlayGlow.ts; const glowAlpha = glowElapsed < overlayGlow.dur ? (1 - glowElapsed/overlayGlow.dur) : 0;
 if(singleCooldown>0) singleCooldown--; // decrease cooldown each frame
 if(glowAlpha > 0 && overlayGlow.type){ ctx.save(); ctx.globalCompositeOperation = 'lighter'; const skinR = drumR + 4; const outerR = drumR + 16; const angleLeftStart = Math.PI/2; const angleLeftEnd = 3*Math.PI/2; const angleRightStart = -Math.PI/2; const angleRightEnd = Math.PI/2;
   if(overlayGlow.type === 'don'){ // inner semi-circle on skin circle (red)
     ctx.fillStyle = `rgba(255,90,90,${0.95*glowAlpha})`;
     ctx.beginPath(); if(overlayGlow.side === 'left'){
       ctx.moveTo(drumCenterX, drumCenterY);
       ctx.arc(drumCenterX, drumCenterY, skinR, angleLeftStart, angleLeftEnd);
       ctx.closePath(); ctx.fill();
     } else {
       ctx.moveTo(drumCenterX, drumCenterY);
       ctx.arc(drumCenterX, drumCenterY, skinR, angleRightStart, angleRightEnd);
       ctx.closePath(); ctx.fill();
     }
   }
   if(overlayGlow.type === 'ka'){ // annulus for kats (between skinR and outerR)
     ctx.fillStyle = `rgba(66,164,245,${0.95*glowAlpha})`;
     ctx.beginPath(); if(overlayGlow.side === 'left'){
       ctx.arc(drumCenterX, drumCenterY, outerR, angleLeftStart, angleLeftEnd);
       ctx.arc(drumCenterX, drumCenterY, skinR, angleLeftEnd, angleLeftStart, true);
       ctx.closePath(); ctx.fill();
     } else {
       ctx.arc(drumCenterX, drumCenterY, outerR, angleRightStart, angleRightEnd);
       ctx.arc(drumCenterX, drumCenterY, skinR, angleRightEnd, angleRightStart, true);
       ctx.closePath(); ctx.fill();
     }
   }
   // thin dividing vertical line for clarity
   ctx.lineWidth = 2 + 2*glowAlpha;
   ctx.strokeStyle = `rgba(0,0,0,${0.35*glowAlpha})`;
   ctx.beginPath(); ctx.moveTo(drumCenterX, drumCenterY - outerR - 8); ctx.lineTo(drumCenterX, drumCenterY + outerR + 8); ctx.stroke();
   ctx.globalCompositeOperation = 'source-over'; ctx.restore(); }

 ctx.beginPath(); ctx.fillStyle='#000'; ctx.arc(drumCenterX,drumCenterY,drumR+10,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--skin')||'#f3d0b0'; ctx.arc(drumCenterX,drumCenterY,drumR+4,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle='#11131a'; ctx.arc(drumCenterX,drumCenterY,drumR,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.05)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(drumCenterX-drumR,drumCenterY); ctx.lineTo(drumCenterX+drumR,drumCenterY); ctx.stroke(); // rim guides
 ctx.beginPath(); ctx.strokeStyle='rgba(66,164,245,0.12)'; ctx.lineWidth=10; ctx.arc(drumCenterX,drumCenterY,drumRimOuter,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle='rgba(255,90,90,0.12)'; ctx.lineWidth=8; ctx.arc(drumCenterX,drumCenterY,drumR+2,0,Math.PI*2); ctx.stroke(); // rect character bigger
 const rectW=90,rectH=36,rectX=drumCenterX-rectW/2,rectY=drumCenterY-drumR-56; ctx.save(); let yOffset=0,s=1; if(overlayRect.depressed) yOffset=8; if(overlayRect.vibeScale>1) s=overlayRect.vibeScale; ctx.translate(drumCenterX,rectY+yOffset); ctx.scale(1,s); ctx.translate(-drumCenterX,-(rectY+yOffset)); ctx.fillStyle=overlayRect.depressed? '#4b1b1b':'#222'; ctx.fillRect(rectX,rectY,rectW,rectH); ctx.strokeStyle='#444'; ctx.strokeRect(rectX,rectY,rectW,rectH); ctx.restore(); // combo (centered vertically on drum)
 ctx.textAlign='center'; ctx.fillStyle='#ffd'; ctx.font=`${34*comboScale}px Nunito, Inter, system-ui`; ctx.fillText(combo.toString(), drumCenterX, drumCenterX? drumCenterY+12: drumCenterY+12); }

const overlayState = {leftSurface:false,leftRim:false,rightSurface:false,rightRim:false}; const overlayRect = {depressed:false,vibeScale:1,lastVibe:0}; function pressOverlay(side){ if(side==='don-left'){ overlayState.leftSurface=true; setTimeout(()=>overlayState.leftSurface=false,140);} if(side==='ka-left'){ overlayState.leftRim=true; setTimeout(()=>overlayState.leftRim=false,140);} if(side==='don-right'){ overlayState.rightSurface=true; setTimeout(()=>overlayState.rightSurface=false,140);} if(side==='ka-right'){ overlayState.rightRim=true; setTimeout(()=>overlayState.rightRim=false,140);} } function triggerRectOnMiss(){ overlayRect.depressed=true; setTimeout(()=>overlayRect.depressed=false,300);} function triggerRectOnHit(){ overlayRect.vibeScale=1.18; overlayRect.lastVibe=performance.now(); }

// draw bottom pads
function drawBottomPads(){ padWidth = W / padCount; const y = H - padHeight; for(let i=0;i<padCount;i++){ const x = i*padWidth; ctx.save(); ctx.fillStyle = padState[i] ? 'rgba(255,255,255,0.12)' : 'rgba(255,255,255,0.06)'; ctx.fillRect(x,y,padWidth-1,padHeight); ctx.strokeStyle='rgba(0,0,0,0.2)'; ctx.strokeRect(x,y,padWidth-1,padHeight); ctx.restore(); } }

// judgement outline flash
let judgementOutline = {type:null,ts:0,dur:300};
function flashOutline(t){ judgementOutline.type=t; judgementOutline.ts=performance.now(); }

// draw notes: non-flying (incoming) in drawNotes, flying (post-hit) drawn above overlay by drawFlying
function drawNotes(songTime){ flyingNotes.length = 0; const visible = scheduledNotes.filter(n=>n.timeMs - songTime <= lookaheadMs && (songTime - n.timeMs) < lookaheadMs); const nonFlying = []; for(const n of visible){ if(n.hit && n.hitTime!=null) flyingNotes.push(n); else nonFlying.push(n); } nonFlying.sort((a,b)=>b.timeMs-a.timeMs); // incoming notes behind
 for(const n of nonFlying){ const x = noteXAtTime(n.timeMs,songTime); let y=laneY; let alpha=n.alpha??1; if(n.hit && n.hitTime!=null){ const t=(songTime - n.hitTime); const vy0 = n.vy || -0.45; const ay = n.ay || 0.0016; y = laneY + vy0*t + 0.5*ay*t*t; if(x<140) alpha=Math.max(0,(x-20)/120); n.alpha=alpha; if(t>1400) n.judged=true; } if(n.judged) continue; if(x < -120 || x > W + 120) continue; ctx.save(); ctx.globalAlpha = alpha; const coreR = noteRadius - 8; const skinStroke = 3; const blackStroke = 4; ctx.beginPath(); ctx.fillStyle = drawColor(n.color); ctx.arc(x,y,coreR,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.lineWidth = skinStroke; ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--skin')||'#f3d0b0'; ctx.arc(x,y,coreR + skinStroke/2 + 1,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.lineWidth = blackStroke; ctx.strokeStyle = strokeColor; ctx.arc(x,y,coreR + skinStroke/2 + 1 + blackStroke/2 + 1,0,Math.PI*2); ctx.stroke(); if(n.isBig){ ctx.beginPath(); ctx.lineWidth = 4; ctx.strokeStyle = 'rgba(255,215,120,0.9)'; ctx.arc(x,y,coreR+8,0,Math.PI*2); ctx.stroke(); } ctx.restore(); }
}

function drawFlying(songTime){ // draw hit notes above overlay so they appear foreground
  flyingNotes.sort((a,b)=>b.timeMs-a.timeMs);
  for(const n of flyingNotes){ const x = noteXAtTime(n.timeMs,songTime); let y=laneY; let alpha=n.alpha??1; if(n.hit && n.hitTime!=null){ const t=(songTime - n.hitTime); const vy0 = n.vy || -0.45; const ay = n.ay || 0.0016; y = laneY + vy0*t + 0.5*ay*t*t; if(x<140) alpha=Math.max(0,(x-20)/120); n.alpha=alpha; if(t>1400) n.judged=true; } if(n.judged) continue; if(x < -120 || x > W + 120) continue; ctx.save(); ctx.globalAlpha = alpha; const coreR = noteRadius - 8; const skinStroke = 3; const blackStroke = 4; ctx.beginPath(); ctx.fillStyle = drawColor(n.color); ctx.arc(x,y,coreR,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.lineWidth = skinStroke; ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--skin')||'#f3d0b0'; ctx.arc(x,y,coreR + skinStroke/2 + 1,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.lineWidth = blackStroke; ctx.strokeStyle = strokeColor; ctx.arc(x,y,coreR + skinStroke/2 + 1 + blackStroke/2 + 1,0,Math.PI*2); ctx.stroke(); if(n.isBig){ ctx.beginPath(); ctx.lineWidth = 4; ctx.strokeStyle = 'rgba(255,215,120,0.9)'; ctx.arc(x,y,coreR+8,0,Math.PI*2); ctx.stroke(); } ctx.restore(); }
}

// judgement text handling
function showJudgementText(kind){
  const el = document.getElementById('judgement');
  const rect = canvas.getBoundingClientRect();
  const left = rect.left + judgementX;
  el.style.left = left + 'px';
  el.className = 'judgementText';
  el.innerText = kind;
  // set colour based on judgement kind
  if (kind === 'PERFECT' || kind === 'Perfect') el.style.color = '#FFD700'; // yellow
  else if (kind === 'GOOD' || kind === 'Good') el.style.color = '#FFFFFF'; // white
  else if (kind === 'MISS' || kind === 'Miss') el.style.color = '#FF0000'; // red
  else el.style.color = '#FFFFFF';

  el.style.top = (rect.top + laneY - noteRadius - 40) + 'px';
  el.style.opacity = 1;
  el.style.transform = 'translate(-50%, 0px)';
  setTimeout(()=>{ el.style.opacity=0; el.style.transform='translate(-50%,-8px)'; }, 400);
}

// hit logic with big notes and two-hand detection
function tryHit(key, songTime, opts = {}){ // record key time
 lastKeyTimes[key] = performance.now(); let candidate=null; let bestDt=Infinity;
 const hitXThreshold = 120; // only consider notes near judgement X for pointer/touch reliability
 for(const n of scheduledNotes){ if(n.judged || n.hit) continue; const dt = Math.abs(n.timeMs - songTime); const x = noteXAtTime(n.timeMs, songTime); if(dt < bestDt && dt <= lateWindow && Math.abs(x - judgementX) <= hitXThreshold){ candidate = n; bestDt = dt; } }
 // if this was a pointer/touch call and no candidate, don't show miss (silently ignore)
 if(!candidate){ if(opts.ignoreMiss) return; flashOutline('miss'); showJudgementText('Miss'); combo = 0; score = Math.max(0, score - 20); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); return; }
 const keyColor = colorForKey(key);
 if(keyColor !== candidate.color){ // wrong color -> miss
   if(opts.ignoreMiss){ // don't punish on touch
     return;
   }
   candidate.judged=true; candidate.hit=true; flashOutline('miss'); showJudgementText(candidate.isBig ? 'MISS' : 'Miss'); combo=0; score=Math.max(0, score-50); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); return;
 }
 // determine side and type for overlay glow based on which key was used (will show on keypress and here for safety)
 const isDonKey = (key === 'f' || key === 'j');
 const side = (key === 'f' || key === 'd') ? 'left' : 'right';
 const glowInfo = { type: isDonKey ? 'don' : 'ka', side };
 // big note handling
 if(candidate.isBig){ // check two-hand: if don (red) need f and j; if kat (blue) need d and k
   const now = performance.now(); const isDon = candidate.color==='red';
   if(isDon){ const both = Math.abs(lastKeyTimes.f - lastKeyTimes.j) < 140 && Math.min(lastKeyTimes.f,lastKeyTimes.j) > (now - 8000);
     if(bestDt <= perfectWindow){ // perfect (BIG only shows text/effects)
       showJudgementText('PERFECT'); flashOutline('perfect'); if(both){ score += 600; } else { score += 300; }
     } else if(bestDt <= goodWindow){ showJudgementText(both? 'GOOD' : 'Good'); flashOutline('good'); if(both) score += 200; else score += 100; }
     else { flashOutline('miss'); showJudgementText('MISS'); combo=0; score=Math.max(0, score-50); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); candidate.judged=true; candidate.hit=true; return; }
     // play sound: bonus only when both
     playHitSound('don', candidate.isBig, both);
   } else { const both = Math.abs(lastKeyTimes.d - lastKeyTimes.k) < 140 && Math.min(lastKeyTimes.d,lastKeyTimes.k) > (now - 8000);
     if(bestDt <= perfectWindow){ showJudgementText('PERFECT'); flashOutline('perfect'); if(both){ score += 600; } else { score += 300; } }
     else if(bestDt <= goodWindow){ showJudgementText(both? 'GOOD' : 'Good'); flashOutline('good'); if(both) score += 200; else score += 100; }
     else { flashOutline('miss'); showJudgementText('MISS'); combo=0; score=Math.max(0, score-50); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); candidate.judged=true; candidate.hit=true; return; }
     playHitSound('ka', candidate.isBig, both);
   }
   // successful big hit
   combo++; updateScoreDisplay(); animateCombo(); triggerRectOnHit();
   // Make the jump 1.5x higher: increase magnitude of upward velocity
   const baseVy = -0.6; candidate.vy = baseVy * 1.5; candidate.ay = 0.0016; candidate.alpha = 1;
   candidate.hit=true; candidate.judged=false; candidate.hitTime = songTime; triggerOverlayGlow(glowInfo);
   return;
 }
 // normal note
 if(bestDt <= perfectWindow){ // normal perfect: no text/effects per request
   combo++; score += 300; updateScoreDisplay(); animateCombo(); triggerRectOnHit();
   const baseVyN = -0.45; candidate.vy = baseVyN * 1.5; candidate.ay = 0.0016; candidate.alpha = 1;
   candidate.hit=true; candidate.judged=false; candidate.hitTime=songTime; triggerOverlayGlow(glowInfo); playHitSound(candidate.color==='red'?'don':'ka', candidate.isBig, false); return; }
 if(bestDt <= goodWindow){ showJudgementText('Good'); flashOutline('good'); combo++; score += 100; updateScoreDisplay(); animateCombo(); triggerRectOnHit();
   const baseVyN2 = -0.35; candidate.vy = baseVyN2 * 1.5; candidate.ay = 0.0016; candidate.alpha = 1;
   candidate.hit=true; candidate.judged=false; candidate.hitTime=songTime; triggerOverlayGlow(glowInfo); playHitSound(candidate.color==='red'?'don':'ka', candidate.isBig, false); return; }
 // too late
 candidate.judged=true; candidate.hit=true; flashOutline('miss'); showJudgementText('Miss'); combo=0; score=Math.max(0,score-50); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); }

function animateCombo(){ comboScale = 1.28; comboLastUpdated = performance.now(); }

// input handlers
function handleKeyPressVisual(k){ // visual + glow on key press (user requested glow on keydown)
  if(k==='f') { pressOverlay('don-left'); triggerOverlayGlow({type:'don', side:'left'}); playHitSound('don', false, false); }
  if(k==='d') { pressOverlay('ka-left'); triggerOverlayGlow({type:'ka', side:'left'}); playHitSound('ka', false, false); }
  if(k==='j') { pressOverlay('don-right'); triggerOverlayGlow({type:'don', side:'right'}); playHitSound('don', false, false); }
  if(k==='k') { pressOverlay('ka-right'); triggerOverlayGlow({type:'ka', side:'right'}); playHitSound('ka', false, false); }
}
document.addEventListener('keydown', e=>{ const k=e.key.toLowerCase(); if(!(['f','j','d','k'].includes(k))) return; lastKeyTimes[k]=performance.now(); handleKeyPressVisual(k); if(startTime!=null){ tryHit(k, performance.now()-startTime); } });

// pointer/touch handling (restored multitouch-friendly touchstart) - mapping corrected, and we use spatial tolerance so touching the drum doesn't accidentally miss
function processPointerDown(px, py){ const x = px, y = py; if(y>=H-padHeight){ const col = Math.floor(x / padWidth); const idx = Math.max(0, Math.min(padCount-1, col)); padState[idx]=true; setTimeout(()=>padState[idx]=false,120); const keyMap=['d','f','j','k']; const key=keyMap[idx]; lastKeyTimes[key]=performance.now(); handleKeyPressVisual(key); if(startTime!=null) tryHit(key, performance.now()-startTime, {ignoreMiss:true}); } else { if(x < overlayLeft + overlayWidth){ const dx=x-drumCenterX, dy=y-drumCenterY; const r=Math.sqrt(dx*dx+dy*dy); if(r <= drumR * 0.85){ if(dx<0){ pressOverlay('don-left'); triggerOverlayGlow({type:'don', side:'left'}); if(startTime!=null) tryHit('f', performance.now()-startTime, {ignoreMiss:true}); } else { pressOverlay('don-right'); triggerOverlayGlow({type:'don', side:'right'}); if(startTime!=null) tryHit('j', performance.now()-startTime, {ignoreMiss:true}); } } else if(r <= drumRimOuter){ if(dx<0){ pressOverlay('ka-left'); triggerOverlayGlow({type:'ka', side:'left'}); if(startTime!=null) tryHit('d', performance.now()-startTime, {ignoreMiss:true}); } else { pressOverlay('ka-right'); triggerOverlayGlow({type:'ka', side:'right'}); if(startTime!=null) tryHit('k', performance.now()-startTime, {ignoreMiss:true}); } } } } }
canvas.addEventListener('pointerdown', e=>{ const rect=canvas.getBoundingClientRect(); processPointerDown(e.clientX-rect.left, e.clientY-rect.top); });
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); const rect=canvas.getBoundingClientRect(); for(const t of e.changedTouches){ processPointerDown(t.clientX-rect.left, t.clientY-rect.top); } }, {passive:false});

// improved autoplay: hit up to 3 notes per frame, pick ones closest to PERFECT and show visual, alternate left/right
function autoTick(songTime){ if(!autoMode) return; let attempts=0; while(attempts<3){ let candidate=null, bestDt=Infinity; for(const n of scheduledNotes){ if(n.judged || n.hit) continue; const dt = Math.abs(n.timeMs - songTime); if(dt < bestDt){ candidate=n; bestDt=dt; } } if(!candidate) break; if(bestDt <= perfectWindow){ // pick key according to alternating turn and color mapping
   let key;
   if(autoLeftTurn){ // left side turn: df are left
     key = candidate.color === 'red' ? 'f' : 'd';
   } else { // right side turn: jk are right
     key = candidate.color === 'red' ? 'j' : 'k';
   }
   autoLeftTurn = !autoLeftTurn; // toggle for next
   handleKeyPressVisual(key);
   tryHit(key, songTime);
   attempts++;
   continue;
 } break; } }

// BPM controls
const bpmDisplay = document.getElementById('bpmDisplay'); function setBPM(newBPM){ bpm = Math.max(-1, Math.min(300, newBPM)); // allow -1
  bpmDisplay.textContent = bpm === -1 ? 'BPM: -1 (off)' : 'BPM: ' + bpm;
  beatMs = 60000 / (bpm || 1);
  gridMs = beatMs / subdivisionsPerBeat;
  scheduledNotes = [];
  lastScheduledBeatIndex = -1;
  lastColors = [];
  lastGroup = [];
  startTime = performance.now();
  score = 0;
  combo = 0;
  updateScoreDisplay();
}
document.getElementById('bpmUp').addEventListener('click', ()=> setBPM(bpm+5));
document.getElementById('bpmDown').addEventListener('click', ()=> setBPM(bpm-5));

// main loop
let lastTs = performance.now(); function gameLoop(ts){ if(isPaused) { requestAnimationFrame(gameLoop); return; } if(!startTime) startTime = ts; const songTime = ts - startTime; const dt = ts - lastTs; lastTs = ts; fillSchedule(songTime); autoTick(songTime); if(comboScale>1){ const elapsed=performance.now()-comboLastUpdated; comboScale = Math.max(1, 1 + (comboScale-1) * Math.max(0,1 - elapsed/200)); } if(overlayRect.vibeScale>1){ const ev=performance.now()-overlayRect.lastVibe; overlayRect.vibeScale = Math.max(1,1 + (overlayRect.vibeScale-1) * Math.max(0,1 - ev/200)); } ctx.clearRect(0,0,W,H); drawBackground(dt); drawLane(); drawBarlines(songTime);
 // judgement circle behind notes
 ctx.save(); ctx.strokeStyle = 'rgba(200,200,200,0.5)'; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(judgementX, laneY, noteRadius+10, 0, Math.PI*2); ctx.stroke(); ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(judgementX, laneY, noteRadius, 0, Math.PI*2); ctx.stroke(); ctx.restore();
 drawNotes(songTime); drawOverlay(); drawFlying(songTime); drawBottomPads(); // draw judgement outline if active
 if(judgementOutline.type && performance.now() - judgementOutline.ts < judgementOutline.dur){ const progress = (performance.now() - judgementOutline.ts) / judgementOutline.dur; ctx.save(); if(judgementOutline.type === 'good'){ ctx.strokeStyle = 'rgba(255,255,255,' + (1-progress) + ')'; } else if(judgementOutline.type === 'perfect'){ ctx.strokeStyle = 'rgba(255,200,0,' + (1-progress) + ')'; } else { ctx.strokeStyle = 'rgba(255,80,80,' + (1-progress) + ')'; } ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(judgementX, laneY, noteRadius+12 + (1-progress)*6, 0, Math.PI*2); ctx.stroke(); ctx.restore(); } // auto-miss handling
 for(const n of scheduledNotes){ if(!n.judged && !n.hit && (songTime - n.timeMs) > lateWindow){ n.judged = true; n.hit = true; combo = 0; score = Math.max(0, score-50); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); flashOutline('miss'); showJudgementText('Miss'); } }
 // cleanup
 scheduledNotes = scheduledNotes.filter(n => { if(n.judged) return false; if(n.hit && n.hitTime!=null && (songTime - n.hitTime) > 1600) return false; if((songTime - n.timeMs) > lookaheadMs) return false; return true; }); requestAnimationFrame(gameLoop); }

// draw barlines (as tall as the note lane)
function drawBarlines(songTime){ const subdivisionsPerBar = subdivisionsPerBeat * 4; const firstBeatIndex = Math.floor(songTime / gridMs); const lastBeatIndex = Math.floor((songTime + lookaheadMs) / gridMs); ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1; const laneTop = laneY - laneH/2; const laneBottom = laneY + laneH/2; for(let bi=firstBeatIndex; bi<=lastBeatIndex; bi++){ if(bi % subdivisionsPerBar === 0){ const x = noteXAtTime(bi * gridMs, songTime); ctx.beginPath(); ctx.moveTo(x,laneTop); ctx.lineTo(x,laneBottom); ctx.stroke(); } } ctx.restore(); }

// flash outline helper (already defined above, but ensure consistent)
function flashOutline(t){ judgementOutline.type = (t==='good' ? 'good' : (t==='perfect' ? 'perfect' : 'miss')); judgementOutline.ts = performance.now(); }

// resize
window.addEventListener('resize', ()=>{ W = canvas.width = canvas.clientWidth || 1000; H = canvas.height = canvas.clientHeight || 520; overlayRight = judgementX - 60; overlayWidth = overlayRight - overlayLeft; padWidth = W / padCount; drumCenterX = overlayRight - 60; drumRimOuter = drumR + 24; drumCenterY = laneY; drumR = Math.max(40, Math.min(80, Math.round(W*0.052))); padHeight = Math.max(96, Math.round(H*0.22)); semiCenterX = W/2; semiRadius = W * 0.6; });

// ------------------ Nerinyan song select integration ------------------
const songSelectOverlay = document.getElementById('songSelectOverlay');
const ssQuery = document.getElementById('ssQuery');
const ssSearch = document.getElementById('ssSearch');
const ssClose = document.getElementById('ssClose');
const ssResults = document.getElementById('ssResults');
const previewTitle = document.getElementById('previewTitle');
const previewMeta = document.getElementById('previewMeta');
const previewThumb = document.getElementById('previewThumb');
const bgPreviewContainer = document.getElementById('bgPreviewContainer');
const btnDownloadMap = document.getElementById('btnDownloadMap');
const btnLoadMap = document.getElementById('btnLoadMap');
const openSongSelect = document.getElementById('openSongSelect');
let nerinyanSelected = null; // store selected item
let baseNotes = []; // <--- store original notes for reload
let useChart = false;
let chartTitle = '';
const chartInfo = document.getElementById('chartInfo');

openSongSelect.addEventListener('click', ()=>{ songSelectOverlay.style.display = 'flex'; ssQuery.focus(); });
ssClose.addEventListener('click', ()=>{ songSelectOverlay.style.display = 'none'; });

async function searchNerinyan(q){ ssResults.innerHTML = '<div style="color:#aaa;padding:8px">Searching…</div>';
  try{
    const res = await fetch('https://api.nerinyan.moe/search?q=' + encodeURIComponent(q));
    const data = await res.json();
    const items = data.results || data || [];
    renderSearchResults(items);
  }catch(err){ ssResults.innerHTML = '<div style="color:#f88;padding:8px">Search failed</div>'; console.error(err); }
}

function renderSearchResults(items){ ssResults.innerHTML = ''; if(!items || items.length===0){ ssResults.innerHTML = '<div style="padding:8px;color:#aaa">No results</div>'; return; }
  for(const it of items){ const el = document.createElement('div'); el.className='song-item'; const thumb = document.createElement('div'); thumb.className='song-thumb'; thumb.style.backgroundImage = '';
    const meta = document.createElement('div'); meta.style.flex='1'; const title = document.createElement('div'); title.className='song-title'; title.textContent = (it.title || it.beatmapset_title || it.name || "Untitled"); const sub = document.createElement('div'); sub.className='song-meta'; let artist = it.artist || it.beatmapset_artist || it.creator || it.uploader || ''; let creator = it.creator || it.uploader || it.author || ''; sub.textContent = (artist?artist+' — ':'') + (creator?creator:''); meta.appendChild(title); meta.appendChild(sub);
    el.appendChild(thumb); el.appendChild(meta);
    el.addEventListener('click', ()=> selectNerinyanItem(it, thumb, title, sub)); ssResults.appendChild(el);
  }
}

async function selectNerinyanItem(item, thumbEl, titleEl, subEl){ nerinyanSelected = item; previewTitle.textContent = item.title || item.beatmapset_title || item.name || 'Untitled'; previewMeta.textContent = (item.artist || item.beatmapset_artist || '') + ' — ' + (item.creator || item.uploader || item.author || ''); // load background by beatmapset id
  const bsid = item.beatmapset_id || item.beatmapset || item.beatmapsetId || item.set_id || item.setId;
  if(bsid){ try{ const bgUrl = 'https://api.nerinyan.moe/bg/' + bsid; previewThumb.style.backgroundImage = `url(${bgUrl})`; previewThumb.style.backgroundSize='cover'; bgPreviewContainer.style.backgroundImage = `url(${bgUrl})`; bgPreviewContainer.style.backgroundSize='cover'; bgPreviewContainer.style.backgroundPosition='center'; }catch(e){ console.warn(e); } }
}

ssSearch.addEventListener('click', ()=>{ const q = ssQuery.value.trim(); if(!q) return; searchNerinyan(q); }); ssQuery.addEventListener('keydown', e=>{ if(e.key==='Enter'){ ssSearch.click(); } });

async function downloadMapFromNerinyan(map){ if(!map) return null; const id = map.id || map.beatmap_id || map.beatmapId || map.beatmapset_id || map.beatmapset || map.special_id; if(!id) throw new Error('No usable id on map'); const url = 'https://api.nerinyan.moe/d/' + id; const resp = await fetch(url); if(!resp.ok) throw new Error('Download failed: '+resp.status); const ab = await resp.arrayBuffer(); return ab; }

async function loadOszArrayBuffer(ab){ const zip = await JSZip.loadAsync(ab); let osuFile = null; let audioFileEntry = null; for(const fname of Object.keys(zip.files)){ if(fname.toLowerCase().endsWith('.osu')){ osuFile = zip.files[fname]; break; } }
  if(!osuFile) throw new Error('No .osu found inside archive'); const osuText = await osuFile.async('string'); const parsed = parseOsu(osuText);
  // find audio
  const audioExts = ['.mp3','.ogg','.wav','.flac','.m4a']; for(const fname of Object.keys(zip.files)){ for(const ex of audioExts){ if(fname.toLowerCase().endsWith(ex)){ audioFileEntry = zip.files[fname]; break; } } if(audioFileEntry) break; }
  let audioBlob = null; if(audioFileEntry){ const ab2 = await audioFileEntry.async('arraybuffer'); const name = audioFileEntry.name.toLowerCase(); const mime = name.endsWith('.mp3')? 'audio/mpeg' : name.endsWith('.ogg')? 'audio/ogg' : name.endsWith('.wav')? 'audio/wav' : 'audio/mpeg'; audioBlob = new Blob([ab2], {type: mime}); }
  scheduledNotes = parsed.notes.map(n=>({...n, hit:false, judged:false, hitTime:null, vy:0, ay:0.0016, alpha:1}));
  baseNotes = parsed.notes.map(n=>({...n})); // <--- store original notes
  scheduledNotes.sort((a,b)=>a.timeMs-b.timeMs);
  resetSchedulingState();
  // --- fix: reset scheduling state so notes always spawn from start ---
  lastScheduledBeatIndex = -1;
  lastGroup = [];
  lastColors = [];
  useChart = true; chartTitle = parsed.general.Title || '';
  chartInfo.textContent = (chartTitle || 'Chart loaded') + ' — notes: ' + scheduledNotes.length;
  if(audioBlob){ if(audioURL) URL.revokeObjectURL(audioURL); audioURL = URL.createObjectURL(audioBlob); if(audioEl) audioEl.src = audioURL; else { audioEl = new Audio(audioURL); audioEl.crossOrigin = 'anonymous'; audioEl.preload='auto'; }
    connectAudioElementToCtx(audioEl);
  }
  updateScoreDisplay();
}

btnDownloadMap.addEventListener('click', async ()=>{
  if(!nerinyanSelected){ alert('Select a map first'); return; }
  try{ btnDownloadMap.textContent='Downloading...'; const ab = await downloadMapFromNerinyan(nerinyanSelected); await loadOszArrayBuffer(ab); btnDownloadMap.textContent='Downloaded'; }catch(err){ alert('Download failed: '+err.message); console.error(err); btnDownloadMap.textContent='Download Map'; }
});

btnLoadMap.addEventListener('click', ()=>{
  if(!scheduledNotes || scheduledNotes.length===0){ alert('No map loaded. Download a map or load an OSZ.'); return; }
  songSelectOverlay.style.display = 'none';
});

// ------------------ minimal .osu parser (used by OSZ loader) ------------------
function parseOsu(text){ const lines = text.split(/\r?\n/).map(s=>s.trim()); let inHitObjects = false; let notes=[]; let general = {}; for(const L of lines){ if(L.length===0) continue; if(L.startsWith('[')){ inHitObjects = L.toLowerCase().startsWith('[hitobjects]'); continue; } if(inHitObjects){ const parts = L.split(','); if(parts.length < 5) continue; const time = parseInt(parts[2],10); const hitSound = parseInt(parts[4],10) || 0; const isBig = (hitSound & 4) !== 0; const isKat = (hitSound & 2) !== 0 || (hitSound & 8) !== 0; const color = isKat ? 'blue' : 'red'; notes.push({timeMs: time, color: color, isBig: isBig}); } else { const ci = L.indexOf(':'); if(ci!==-1){ const k=L.slice(0,ci).trim(); const v=L.slice(ci+1).trim(); general[k] = v; } } } return {notes: notes, general}; }

// ------------------ OSZ local loader (for user-provided OSZ) ------------------
async function loadOSZFileBuffer(file){ if(!file) return null; let ab = file; if(file.arrayBuffer) ab = await file.arrayBuffer(); const zip = await JSZip.loadAsync(ab); let osuFile = null; let audioFileEntry = null; for(const fname of Object.keys(zip.files)){ if(fname.toLowerCase().endsWith('.osu')){ osuFile = zip.files[fname]; break; } }
  if(!osuFile) throw new Error('No .osu found inside archive'); const osuText = await osuFile.async('string'); const parsed = parseOsu(osuText);
  const audioExts = ['.mp3','.ogg','.wav','.flac','.m4a']; for(const fname of Object.keys(zip.files)){ for(const ex of audioExts){ if(fname.toLowerCase().endsWith(ex)){ audioFileEntry = zip.files[fname]; break; } } if(audioFileEntry) break; }
  let audioBlob = null; if(audioFileEntry){ const ab2 = await audioFileEntry.async('arraybuffer'); const name = audioFileEntry.name.toLowerCase(); const mime = name.endsWith('.mp3')? 'audio/mpeg' : name.endsWith('.ogg')? 'audio/ogg' : name.endsWith('.wav')? 'audio/wav' : 'audio/mpeg'; audioBlob = new Blob([ab2], {type: mime}); }
  scheduledNotes = parsed.notes.map(n=>({...n, hit:false, judged:false, hitTime:null, vy:0, ay:0.0016, alpha:1}));
  baseNotes = parsed.notes.map(n=>({...n})); // <--- store original notes
  scheduledNotes.sort((a,b)=>a.timeMs-b.timeMs);
  resetSchedulingState();
  // --- fix: reset scheduling state so notes always spawn from start ---
  lastScheduledBeatIndex = -1;
  lastGroup = [];
  lastColors = [];
  useChart = true; chartTitle = parsed.general.Title || '';
  chartInfo.textContent = (chartTitle || 'Chart loaded') + ' — notes: ' + scheduledNotes.length;
  if(audioBlob){ if(audioURL) URL.revokeObjectURL(audioURL); audioURL = URL.createObjectURL(audioBlob); if(audioEl) audioEl.src = audioURL; else { audioEl = new Audio(audioURL); audioEl.crossOrigin = 'anonymous'; audioEl.preload='auto'; }
    connectAudioElementToCtx(audioEl);
  }
  updateScoreDisplay(); }

// hook up local OSZ loader button
const oszInput = document.getElementById('oszFile'); const loadOSZBtn = document.getElementById('loadOSZ'); loadOSZBtn.addEventListener('click', async ()=>{ const f = oszInput.files[0]; if(!f){ alert('Select an .osz file'); return; } try{ await loadOSZFileBuffer(f); }catch(err){ alert('Failed to load .osz: '+err.message); console.error(err); } });

// ------------------ audio element integration (used by Play) ------------------
let audioEl = null, audioURL = null, chartOffsetMs = 0;
function ensureAudioContextForElement(){ if(!audioEl) return; try{ if(!audioCtx) ensureAudio(); connectAudioElementToCtx(audioEl); }catch(e){ console.warn(e); } }

function connectAudioElementToCtx(el){ ensureAudio(); if(!audioCtx) return; try{ if(window.MediaElementAudioSourceNode){ if(mediaSrcNode){ try{ mediaSrcNode.disconnect(); }catch(e){} mediaSrcNode=null; } mediaSrcNode = audioCtx.createMediaElementSource(el); mediaSrcNode.connect(audioCtx.destination); } }catch(e){ console.warn(e); }
}

const playBtn = document.getElementById('playBtn');
playBtn.addEventListener('click', async ()=>{
  if(!useChart){ alert('Load a chart first'); return; }
  // Always reload notes from baseNotes
  if (baseNotes && baseNotes.length > 0) {
    scheduledNotes = baseNotes.map(n=>({...n, hit:false, judged:false, hitTime:null, vy:0, ay:0.0016, alpha:1}));
  }
  resetSchedulingState();
  // --- Improved sync: set startTime based on actual audio playback ---
  if(audioEl){
    try{
      ensureAudio();
      if(audioCtx && audioCtx.state==='suspended') await audioCtx.resume();
      audioEl.currentTime = 0;
      let started = false;
      // Wait for audio to actually start playing
      const syncStart = () => {
        if (!started && !audioEl.paused && audioEl.currentTime > 0) {
          started = true;
          startTime = performance.now() - audioEl.currentTime * 1000;
        }
      };
      audioEl.removeEventListener('playing', syncStart);
      audioEl.addEventListener('playing', syncStart, { once: true });
      const playPromise = audioEl.play();
      if(playPromise && playPromise.then) await playPromise;
      // Fallback: if 'playing' doesn't fire, set startTime after play
      setTimeout(() => {
        if (!started) startTime = performance.now() - audioEl.currentTime * 1000;
      }, 100);
    }catch(e){
      startTime = performance.now();
    }
  } else {
    startTime = performance.now();
  }
});

// --- Pause menu logic ---
const pauseOverlay = document.getElementById('pauseOverlay');
const pauseContinue = document.getElementById('pauseContinue');
const pauseRestart = document.getElementById('pauseRestart');
const pauseQuit = document.getElementById('pauseQuit');
let isPaused = false;
let pauseTime = 0;
let pauseSongTime = 0;

function showPauseMenu() {
  if (isPaused) return;
  isPaused = true;
  pauseOverlay.style.display = 'flex';
  if (audioEl && !audioEl.paused) audioEl.pause();
  pauseTime = performance.now();
  if (startTime != null) pauseSongTime = performance.now() - startTime;
}
function hidePauseMenu() {
  if (!isPaused) return;
  isPaused = false;
  pauseOverlay.style.display = 'none';
  if (audioEl && audioEl.paused) audioEl.play();
  // adjust startTime so song resumes at correct position
  if (startTime != null) startTime = performance.now() - pauseSongTime;
}
pauseContinue.onclick = hidePauseMenu;
pauseQuit.onclick = function() {
  hidePauseMenu();
  // Return to song select
  songSelectOverlay.style.display = 'flex';
  if (audioEl) { audioEl.pause(); audioEl.currentTime = 0; }
  startTime = null;
  scheduledNotes = [];
  lastScheduledBeatIndex = -1;
  lastGroup = [];
  lastColors = [];
  combo = 0; score = 0; updateScoreDisplay();
};
pauseRestart.onclick = function() {
  hidePauseMenu();
  restartCurrentSong();
};

// Keyboard shortcut for pause menu
document.addEventListener('keydown', function(e){
  if (e.key === 'q' || e.key === 'Q') {
    if (!isPaused) showPauseMenu();
    else hidePauseMenu();
  }
});

// --- Fix: Always reset scheduling state and startTime on chart load/restart ---
function resetSchedulingState() {
  lastScheduledBeatIndex = -1;
  lastGroup = [];
  lastColors = [];
  combo = 0; score = 0; updateScoreDisplay();
  startTime = null;
}

// --- Fix: Restart song logic ---
function restartCurrentSong() {
  if (!useChart || !baseNotes || baseNotes.length === 0) return;
  // Reset all notes to unhit/unjudged by reloading from baseNotes
  scheduledNotes = baseNotes.map(n => ({...n, hit:false, judged:false, hitTime:null, vy:0, ay:0.0016, alpha:1}));
  resetSchedulingState();
  // --- Fix: reload audio and sync startTime like Play button ---
  if (audioEl) {
    audioEl.currentTime = 0;
    let started = false;
    const syncStart = () => {
      if (!started && !audioEl.paused && audioEl.currentTime > 0) {
        started = true;
        startTime = performance.now() - audioEl.currentTime * 1000;
      }
    };
    audioEl.removeEventListener('playing', syncStart);
    audioEl.addEventListener('playing', syncStart, { once: true });
    const playPromise = audioEl.play();
    if (playPromise && playPromise.then) playPromise.then(()=>{}).catch(()=>{});
    setTimeout(() => {
      if (!started) startTime = performance.now() - audioEl.currentTime * 1000;
    }, 100);
  } else {
    startTime = performance.now();
  }
}

// start loop
updateScoreDisplay(); requestAnimationFrame(gameLoop);
</script>
</body>
</html>
