<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Taiko Playable — Final Iteration</title>
  <style>
    :root{--skin:#f3d0b0;--bg:#0b0f16;--panel:#1b1b1b}
    body { margin: 0; background: var(--bg); overflow: hidden; font-family: 'Nunito', 'Arial Rounded MT Bold', Inter, system-ui, Arial }
    canvas { display: block; margin: auto; background: transparent; touch-action: none; }
    .judgementText { position: fixed; transform: translate(-50%, -8px); font-size: 28px; font-weight: 800; opacity: 0; pointer-events: none; transition: transform 0.12s ease, opacity 0.12s ease; text-shadow: 0 6px 18px rgba(0,0,0,0.6); font-family: 'Nunito', 'Arial Rounded MT Bold', Inter, system-ui, Arial }
    .score { position: fixed; right: 14px; top: 10px; color: #fff; font-weight:800; font-size:18px; font-family: 'Nunito', 'Arial Rounded MT Bold', Inter, system-ui, Arial }
    .controls { position: fixed; left: 50%; transform: translateX(-50%); bottom: 10px; display:flex; gap:8px; align-items:center; }
    .controls button{ padding:6px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:#131316; color:#fff }
    .controls .bpm { color:#fff; font-weight:700; padding:6px 10px; font-family: 'Nunito' }
    .uploader { position: fixed; left: 10px; top: 10px; font-size: 14px; color:#fff }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
</head>
<body>
<canvas id="gameCanvas" width="1000" height="520"></canvas>
<div id="judgement" class="judgementText"></div>
<div class="score" id="score">Score: 0</div>
<div class="uploader">
  <input id="oszFile" type="file" accept=".osz,.zip"> OSZ
  <button id="loadOSZ">Load OSZ</button>
  <button id="playBtn">Play</button>
  <span id="chartInfo" style="margin-left:10px"></span>
</div>
<div class="controls">
  <button id="bpmDown">-</button>
  <div class="bpm" id="bpmDisplay">BPM: 120</div>
  <button id="bpmUp">+</button>
  <label style="display:flex;align-items:center;gap:6px;color:#fff"><input type="checkbox" id="autoplay">Auto</label>
</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;
const laneY = H * 0.45;
let judgementX = 180;
const noteRadius = 28;
const strokeColor = '#000';
const laneH = 128;

let overlayRight = judgementX - 60;
const overlayLeft = -20;
let overlayWidth = overlayRight - overlayLeft;
let drumCenterX = overlayRight - 60;
let drumCenterY = laneY;
let drumR = 52;
let drumRimOuter = drumR + 24;

let padHeight = 120;
let padCount = 4;
let padWidth = W / padCount;
let padState = [false,false,false,false];

let bpm = 120;
let subdivisionsPerBeat = 4;
let beatMs = 60000 / bpm;
let gridMs = beatMs / subdivisionsPerBeat;
let speedPxPerMs = 0.45 * 1.25;
const lookaheadMs = 8000;

let scheduledNotes = [];
let flyingNotes = [];
let useChart = false;

let audioEl = null, audioURL = null, chartTitle = '', chartOffsetMs = 0;
let bpmEvents = [], measureEvents = [], scrollEvents = [];

let autoMode = false; document.getElementById('autoplay').addEventListener('change', e=>{ autoMode = e.target.checked; });
let autoLeftTurn = true;

const perfectWindow = 25;
const goodWindow = 60;
const lateWindow = 120;

let combo = 0, comboScale = 1, comboLastUpdated = 0, score = 0;
function updateScoreDisplay(){ document.getElementById('score').textContent = 'Score: ' + Math.max(0, Math.floor(score)); }

let startTime = null;

const bgParticles = [];
for(let i=0;i<28;i++) bgParticles.push({x:Math.random()*W,y:Math.random()*H, r:8+Math.random()*60, a:0.04+Math.random()*0.12, vx:(Math.random()-0.5)*0.02, vy:(Math.random()-0.5)*0.02, ang:Math.random()*Math.PI*2});

function drawColor(type){ return type === 'red' ? '#ff5b5b' : '#42a4f5'; }

const lastKeyTimes = {f:0,d:0,j:0,k:0};
document.addEventListener('keydown', e=>{ const k = e.key.toLowerCase(); if (['f','d','j','k'].includes(k)) lastKeyTimes[k] = performance.now(); });

const AudioContextClass = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){ if(audioCtx) return; try{ audioCtx = new AudioContextClass(); }catch(e){ audioCtx = null; } }
function connectAudioElementToCtx(el){ ensureAudio(); if(!audioCtx) return; try{ if(el._connected) return; const src = audioCtx.createMediaElementSource(el); src.connect(audioCtx.destination); el._connected = true; }catch(e){} }
function playHitSound(type,isBig){ ensureAudio(); if(!audioCtx) return; const t = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const g = audioCtx.createGain(); if(type==='don'){ osc.type='sine'; osc.frequency.setValueAtTime(isBig?180:260,t); } else { osc.type='triangle'; osc.frequency.setValueAtTime(isBig?480:360,t); } g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(isBig?0.8:0.65,t+0.002); g.gain.exponentialRampToValueAtTime(0.001,t+0.15); osc.connect(g); g.connect(audioCtx.destination); osc.start(t); osc.stop(t+0.18); if(type==='ka'){ const bufferSize=audioCtx.sampleRate*0.02; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); const data = buffer.getChannelData(0); for(let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * Math.exp(-i/(bufferSize*0.02)); const noise = audioCtx.createBufferSource(); noise.buffer = buffer; const ng = audioCtx.createGain(); ng.gain.setValueAtTime(0.6,t); ng.gain.exponentialRampToValueAtTime(0.001,t+0.08); noise.connect(ng); ng.connect(audioCtx.destination); noise.start(t); noise.stop(t+0.08); } }

function parseOsu(text){
  const lines = text.split(/\r?\n/).map(s=>s.trim());
  let inHitObjects = false; let notes=[]; let general = {};
  for(const L of lines){ if(L.length===0) continue; if(L.startsWith('[')){ inHitObjects = L.toLowerCase().startsWith('[hitobjects]'); continue; }
    if(inHitObjects){ const parts = L.split(','); if(parts.length < 5) continue; const time = parseInt(parts[2],10); const hitSound = parseInt(parts[4],10) || 0; const isBig = (hitSound & 4) !== 0; const isKat = (hitSound & 2) !== 0 || (hitSound & 8) !== 0; const color = isKat ? 'blue' : 'red'; notes.push({timeMs: time, color: color, isBig: isBig}); } else { const ci = L.indexOf(':'); if(ci!==-1){ const k=L.slice(0,ci).trim(); const v=L.slice(ci+1).trim(); general[k] = v; } }
  }
  const out = [];
  for(const n of notes){ const dup = out.some(o=>Math.abs(o.timeMs - n.timeMs) < 1 && o.color===n.color); if(!dup) out.push(n); }
  return {notes: out, general};
}

async function loadOSZFile(file){ if(!file) return null; const data = await file.arrayBuffer(); const zip = await JSZip.loadAsync(data); let osuFile = null; let audioFileEntry = null; for(const fname of Object.keys(zip.files)){ if(fname.toLowerCase().endsWith('.osu')){ osuFile = zip.files[fname]; break; } }
  if(!osuFile) throw new Error('No .osu found inside archive'); const osuText = await osuFile.async('string'); const parsed = parseOsu(osuText);
  const audioFilenameFromOsu = (function(){ const m=osuText.match(/AudioFilename\s*:\s*(.+)/i); return m? m[1].trim(): null; })();
  if(audioFilenameFromOsu){ const key = Object.keys(zip.files).find(k=>k.endsWith(audioFilenameFromOsu)); if(key) audioFileEntry = zip.files[key]; }
  if(!audioFileEntry){ const audioExts = ['.mp3','.ogg','.wav','.flac','.m4a']; for(const fname of Object.keys(zip.files)){ for(const ex of audioExts){ if(fname.toLowerCase().endsWith(ex)){ audioFileEntry = zip.files[fname]; break; } } if(audioFileEntry) break; } }
  let audioBlob = null; if(audioFileEntry){ const ab = await audioFileEntry.async('arraybuffer'); const name = audioFileEntry.name.toLowerCase(); const mime = name.endsWith('.mp3')? 'audio/mpeg' : name.endsWith('.ogg')? 'audio/ogg' : name.endsWith('.wav')? 'audio/wav' : 'audio/mpeg'; audioBlob = new Blob([ab], {type: mime}); }
  return {parsed, audioBlob}; }

const oszInput = document.getElementById('oszFile');
const loadBtn = document.getElementById('loadOSZ');
const playBtn = document.getElementById('playBtn');
const chartInfo = document.getElementById('chartInfo');
const bpmDisplay = document.getElementById('bpmDisplay');

loadBtn.addEventListener('click', async ()=>{
  const f = oszInput.files[0]; if(!f){ alert('Select an .osz file'); return; }
  try{
    const res = await loadOSZFile(f);
    scheduledNotes = [];
    for(const n of res.parsed.notes){ const exists = scheduledNotes.some(s => Math.abs(s.timeMs - n.timeMs) < 1 && s.color === n.color); if(!exists) scheduledNotes.push({timeMs: n.timeMs, color: n.color||'red', isBig: !!n.isBig, hit:false, judged:false, hitTime:null, vy:0, ay:0.0016, alpha:1}); }
    scheduledNotes.sort((a,b)=>a.timeMs - b.timeMs);
    useChart = true;
    chartTitle = res.parsed.general.Title || res.parsed.general.title || '';
    chartInfo.textContent = (chartTitle || 'Chart loaded') + ' — notes: ' + scheduledNotes.length;
    if(res.audioBlob){ if(audioURL) URL.revokeObjectURL(audioURL); audioURL = URL.createObjectURL(res.audioBlob); if(audioEl){ audioEl.src = audioURL; audioEl.load(); } else { audioEl = new Audio(audioURL); audioEl.crossOrigin = 'anonymous'; audioEl.preload='auto'; }
      connectAudioElementToCtx(audioEl);
      audioEl.addEventListener('play', ()=>{ startTime = performance.now() - (audioEl.currentTime*1000) + chartOffsetMs; });
    } else {
      if(audioURL) { URL.revokeObjectURL(audioURL); audioURL = null; }
      audioEl = null;
      startTime = null;
    }
    updateScoreDisplay();
  }catch(err){ alert('Failed to load .osz: '+err.message); console.error(err); }
});

playBtn.addEventListener('click', async ()=>{
  if(!useChart){ alert('Load an .osz (chart) first'); return; }
  if(audioEl){ try{ ensureAudio(); if(audioCtx && audioCtx.state==='suspended') await audioCtx.resume(); const p = audioEl.play(); if(p && p.then) await p; startTime = performance.now() - (audioEl.currentTime*1000) + chartOffsetMs; }catch(e){ startTime = performance.now() + chartOffsetMs; } } else { startTime = performance.now() + chartOffsetMs; }
});

function noteXAtTime(noteOrTime, songTime){ const timeMs = (typeof noteOrTime === 'object') ? noteOrTime.timeMs : noteOrTime; const scroll = 1.0; return judgementX + (timeMs - songTime) * speedPxPerMs * scroll; }
function roundRect(ctx,x,y,w,h,r,fill){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill) ctx.fill(); }
function drawBackground(dt){ ctx.save(); for(const p of bgParticles){ p.x += p.vx * dt; p.y += p.vy * dt; p.ang += 0.0003 * dt; if(p.x<-300) p.x=W+300; if(p.x>W+300) p.x=-300; if(p.y<-300) p.y=H+300; if(p.y>H+300) p.y=-300; ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.ang); ctx.globalAlpha = p.a; ctx.fillStyle='rgba(120,160,200,0.07)'; ctx.beginPath(); ctx.ellipse(0,0,p.r*1.6,p.r,0,0,Math.PI*2); ctx.fill(); ctx.restore(); } ctx.restore(); }
function drawLane(){ const laneWidth = W - 80; const x=40,y=laneY-laneH/2,h=laneH,r=12; ctx.save(); ctx.fillStyle='rgba(255,255,255,0.02)'; roundRect(ctx,x,y,laneWidth,h,r,true); ctx.fillStyle='rgba(255,255,255,0.03)'; roundRect(ctx,x+6,y+12,laneWidth-12,h-24,r-6,true); ctx.restore(); }

function drawNotes(songTime){ flyingNotes.length = 0; const visible = scheduledNotes.filter(n=>n.timeMs - songTime <= lookaheadMs && (songTime - n.timeMs) < lookaheadMs); const nonFlying = []; for(const n of visible){ if(n.hit && n.hitTime!=null) flyingNotes.push(n); else nonFlying.push(n); } nonFlying.sort((a,b)=>b.timeMs-a.timeMs); for(const n of nonFlying){ const x = noteXAtTime(n,songTime); let y = laneY; let alpha = n.alpha ?? 1; if(n.hit && n.hitTime!=null){ const t=(songTime - n.hitTime); const vy0 = n.vy || -0.45; const ay = n.ay || 0.0016; y = laneY + vy0*t + 0.5*ay*t*t; if(x<140) alpha=Math.max(0,(x-20)/120); n.alpha=alpha; if(t>1400) n.judged=true; } if(n.judged) continue; if(x < -120 || x > W + 120) continue; ctx.save(); ctx.globalAlpha = alpha; const coreR = noteRadius - 8; const skinStroke = 3; const blackStroke = 4; ctx.beginPath(); ctx.fillStyle = drawColor(n.color); ctx.arc(x,y,coreR,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.lineWidth = skinStroke; ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--skin')||'#f3d0b0'; ctx.arc(x,y,coreR + skinStroke/2 + 1,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.lineWidth = blackStroke; ctx.strokeStyle = strokeColor; ctx.arc(x,y,coreR + skinStroke/2 + 1 + blackStroke/2 + 1,0,Math.PI*2); ctx.stroke(); if(n.isBig){ ctx.beginPath(); ctx.lineWidth = 4; ctx.strokeStyle = 'rgba(255,215,120,0.9)'; ctx.arc(x,y,coreR+8,0,Math.PI*2); ctx.stroke(); } ctx.restore(); } }
function drawFlying(songTime){ flyingNotes.sort((a,b)=>b.timeMs-a.timeMs); for(const n of flyingNotes){ const x = noteXAtTime(n,songTime); let y = laneY; let alpha = n.alpha ?? 1; if(n.hit && n.hitTime!=null){ const t = (songTime - n.hitTime); const vy0 = n.vy || -0.45; const ay = n.ay || 0.0016; y = laneY + vy0*t + 0.5*ay*t*t; if(x < 140) alpha = Math.max(0, (x-20)/120); n.alpha = alpha; if(t > 1400) n.judged = true; } if(n.judged) continue; if(x < -120 || x > W + 120) continue; ctx.save(); ctx.globalAlpha = alpha; const coreR = noteRadius - 8; const skinStroke = 3; const blackStroke = 4; ctx.beginPath(); ctx.fillStyle = drawColor(n.color); ctx.arc(x,y,coreR,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.lineWidth = skinStroke; ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--skin')||'#f3d0b0'; ctx.arc(x,y,coreR + skinStroke/2 + 1,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.lineWidth = blackStroke; ctx.strokeStyle = strokeColor; ctx.arc(x,y,coreR + skinStroke/2 + 1 + blackStroke/2 + 1,0,Math.PI*2); ctx.stroke(); if(n.isBig){ ctx.beginPath(); ctx.lineWidth = 4; ctx.strokeStyle = 'rgba(255,215,120,0.9)'; ctx.arc(x,y,coreR+8,0,Math.PI*2); ctx.stroke(); } ctx.restore(); } }

let judgementOutline = {type:null,ts:0,dur:300};
function showJudgementText(kind){ if(!kind) return; if(kind.toLowerCase().startsWith('miss')) return; const el = document.getElementById('judgement'); const rect = canvas.getBoundingClientRect(); const left = rect.left + judgementX; el.style.left = left + 'px'; el.className = 'judgementText'; el.innerText = kind; if (kind.toLowerCase().indexOf('perfect')!==-1) el.style.color = '#FFD700'; else if (kind.toLowerCase().indexOf('good')!==-1) el.style.color = '#FFFFFF'; else el.style.color = '#FFFFFF'; el.style.top = (rect.top + laneY - noteRadius - 40) + 'px'; el.style.opacity = 1; el.style.transform = 'translate(-50%, 0px)'; setTimeout(()=>{ el.style.opacity=0; el.style.transform='translate(-50%,-8px)'; }, 400); }

function flashOutline(t){ judgementOutline.type = (t==='good'?'good':(t==='perfect'?'perfect':'miss')); judgementOutline.ts = performance.now(); }

function tryHit(key, songTime, opts = {}){
  lastKeyTimes[key] = performance.now();
  let candidate=null; let bestDt=Infinity; const hitXThreshold = 120;
  for(const n of scheduledNotes){ if(n.judged || n.hit) continue; const dt = Math.abs(n.timeMs - songTime); const x = noteXAtTime(n, songTime); if(dt < bestDt && dt <= lateWindow && Math.abs(x - judgementX) <= hitXThreshold){ candidate = n; bestDt = dt; } }
  if(!candidate){ if(opts.ignoreMiss) return; flashOutline('miss'); combo = 0; score = Math.max(0, score - 20); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); return; }
  if(candidate.hit) return; const keyColor = (key==='f'||key==='j') ? 'red' : 'blue'; if(keyColor !== candidate.color){ if(opts.ignoreMiss) return; candidate.judged=true; candidate.hit=true; flashOutline('miss'); combo=0; score=Math.max(0, score-50); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); return; }
  const isDonKey = (key === 'f' || key === 'j'); const side = (key === 'f' || key === 'd') ? 'left' : 'right'; const glowInfo = { type: isDonKey ? 'don' : 'ka', side };
  if(candidate.isBig){ const now = performance.now(); if(candidate.color === 'red'){ const both = Math.abs(lastKeyTimes.f - lastKeyTimes.j) < 140 && Math.min(lastKeyTimes.f,lastKeyTimes.j) > (now - 8000); if(bestDt <= perfectWindow){ showJudgementText('PERFECT'); flashOutline('perfect'); if(both){ score += 600; } else { score += 300; } } else if(bestDt <= goodWindow){ showJudgementText('GOOD'); flashOutline('good'); if(both) score += 200; else score += 100; } else { flashOutline('miss'); combo=0; score=Math.max(0, score-50); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); candidate.judged=true; candidate.hit=true; return; } playHitSound('don', candidate.isBig); } else { const both = Math.abs(lastKeyTimes.d - lastKeyTimes.k) < 140 && Math.min(lastKeyTimes.d,lastKeyTimes.k) > (now - 8000); if(bestDt <= perfectWindow){ showJudgementText('PERFECT'); flashOutline('perfect'); if(both){ score += 600; } else { score += 300; } } else if(bestDt <= goodWindow){ showJudgementText('GOOD'); flashOutline('good'); if(both) score += 200; else score += 100; } else { flashOutline('miss'); combo=0; score=Math.max(0, score-50); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); candidate.judged=true; candidate.hit=true; return; } playHitSound('ka', candidate.isBig); }
    combo++; updateScoreDisplay(); animateCombo(); triggerRectOnHit(); candidate.vy = -0.6 * 1.5; candidate.ay = 0.0016; candidate.alpha = 1; candidate.hit=true; candidate.judged=false; candidate.hitTime = songTime; triggerOverlayGlow(glowInfo); return; }
  if(bestDt <= perfectWindow){ combo++; score += 300; updateScoreDisplay(); animateCombo(); triggerRectOnHit(); candidate.vy = -0.45 * 1.5; candidate.ay = 0.0016; candidate.alpha = 1; candidate.hit=true; candidate.judged=false; candidate.hitTime=songTime; triggerOverlayGlow(glowInfo); playHitSound(candidate.color==='red'?'don':'ka', candidate.isBig); return; }
  if(bestDt <= goodWindow){ showJudgementText('Good'); flashOutline('good'); combo++; score += 100; updateScoreDisplay(); animateCombo(); triggerRectOnHit(); candidate.vy = -0.35 * 1.5; candidate.ay = 0.0016; candidate.alpha = 1; candidate.hit=true; candidate.judged=false; candidate.hitTime=songTime; triggerOverlayGlow(glowInfo); playHitSound(candidate.color==='red'?'don':'ka', candidate.isBig); return; }
  candidate.judged=true; candidate.hit=true; flashOutline('miss'); combo=0; score=Math.max(0,score-50); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); }

function animateCombo(){ comboScale = 1.28; comboLastUpdated = performance.now(); }

function handleKeyPressVisual(k){ if(k==='f'){ pressOverlay('don-left'); triggerOverlayGlow({type:'don', side:'left'}); playHitSound('don', false); } if(k==='d'){ pressOverlay('ka-left'); triggerOverlayGlow({type:'ka', side:'left'}); playHitSound('ka', false); } if(k==='j'){ pressOverlay('don-right'); triggerOverlayGlow({type:'don', side:'right'}); playHitSound('don', false); } if(k==='k'){ pressOverlay('ka-right'); triggerOverlayGlow({type:'ka', side:'right'}); playHitSound('ka', false); } }

document.addEventListener('keydown', e=>{ const k = e.key.toLowerCase(); if(!(['f','j','d','k'].includes(k))) return; lastKeyTimes[k] = performance.now(); handleKeyPressVisual(k); if(startTime != null) tryHit(k, performance.now()-startTime); });

function processPointerDown(px, py){ const x = px, y = py; if(y>=H-padHeight){ const col = Math.floor(x / padWidth); const idx = Math.max(0, Math.min(padCount-1, col)); padState[idx]=true; setTimeout(()=>padState[idx]=false,120); const keyMap=['d','f','j','k']; const key=keyMap[idx]; lastKeyTimes[key]=performance.now(); handleKeyPressVisual(key); if(startTime!=null) tryHit(key, performance.now()-startTime, {ignoreMiss:true}); } else { if(x < overlayLeft + overlayWidth){ const dx=x-drumCenterX, dy=y-drumCenterY; const r=Math.sqrt(dx*dx+dy*dy); if(r <= drumR * 0.85){ if(dx<0){ pressOverlay('don-left'); triggerOverlayGlow({type:'don', side:'left'}); if(startTime!=null) tryHit('f', performance.now()-startTime, {ignoreMiss:true}); } else { pressOverlay('don-right'); triggerOverlayGlow({type:'don', side:'right'}); if(startTime!=null) tryHit('j', performance.now()-startTime, {ignoreMiss:true}); } } else if(r <= drumRimOuter){ if(dx<0){ pressOverlay('ka-left'); triggerOverlayGlow({type:'ka', side:'left'}); if(startTime!=null) tryHit('d', performance.now()-startTime, {ignoreMiss:true}); } else { pressOverlay('ka-right'); triggerOverlayGlow({type:'ka', side:'right'}); if(startTime!=null) tryHit('k', performance.now()-startTime, {ignoreMiss:true}); } } } } }

canvas.addEventListener('pointerdown', e=>{ const rect = canvas.getBoundingClientRect(); processPointerDown(e.clientX - rect.left, e.clientY - rect.top); });
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); const rect = canvas.getBoundingClientRect(); for(const t of e.changedTouches) processPointerDown(t.clientX - rect.left, t.clientY - rect.top); }, {passive:false});

autoMode = false; document.getElementById('autoplay').addEventListener('change', e=> autoMode = e.target.checked);
function autoTick(songTime){ if(!autoMode) return; let attempts=0; while(attempts<3){ let candidate=null, bestDt=Infinity; for(const n of scheduledNotes){ if(n.judged || n.hit) continue; const dt = Math.abs(n.timeMs - songTime); if(dt < bestDt){ candidate=n; bestDt=dt; } } if(!candidate) break; const x = noteXAtTime(candidate, songTime); if(bestDt <= perfectWindow && Math.abs(x - judgementX) <= 6){ let key; if(autoLeftTurn){ key = candidate.color === 'red' ? 'f' : 'd'; } else { key = candidate.color === 'red' ? 'j' : 'k'; } autoLeftTurn = !autoLeftTurn; handleKeyPressVisual(key); tryHit(key, songTime); attempts++; continue; } break; } }

function drawOverlay(){ const laneYTop = laneY - laneH/2; ctx.fillStyle='#101214'; ctx.fillRect(overlayLeft, laneYTop, overlayWidth+20, laneH); ctx.beginPath(); ctx.fillStyle='#000'; ctx.arc(drumCenterX,drumCenterY,drumR+10,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--skin')||'#f3d0b0'; ctx.arc(drumCenterX,drumCenterY,drumR+4,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle='#11131a'; ctx.arc(drumCenterX,drumCenterY,drumR,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.05)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(drumCenterX-drumR,drumCenterY); ctx.lineTo(drumCenterX+drumR,drumCenterY); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle='rgba(66,164,245,0.12)'; ctx.lineWidth=10; ctx.arc(drumCenterX,drumCenterY,drumRimOuter,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle='rgba(255,90,90,0.12)'; ctx.lineWidth=8; ctx.arc(drumCenterX,drumCenterY,drumR+2,0,Math.PI*2); ctx.stroke(); ctx.textAlign='center'; ctx.fillStyle='#ffd'; ctx.font=`${34*comboScale}px Nunito, Inter, system-ui`; ctx.fillText(combo.toString(), drumCenterX, drumCenterX? drumCenterY+12:drumCenterY+12); }

function drawBarlines(songTime){ const start = songTime; const end = songTime + lookaheadMs; const first = Math.floor(start / gridMs); const last = Math.floor(end / gridMs); const laneTop = laneY - laneH/2; const laneBottom = laneY + laneH/2; ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1; for(let bi=first; bi<=last; bi++){ if(bi % (subdivisionsPerBeat*4) === 0){ const t = bi * gridMs; const x = noteXAtTime(t,songTime); ctx.beginPath(); ctx.moveTo(x,laneTop); ctx.lineTo(x,laneBottom); ctx.stroke(); } } ctx.restore(); }

let lastTs = performance.now();
function gameLoop(ts){ const songTime = startTime != null ? ts - startTime : 0; const dt = ts - lastTs; lastTs = ts; autoTick(songTime); if(comboScale>1){ const elapsed = performance.now()-comboLastUpdated; comboScale = Math.max(1, 1 + (comboScale-1) * Math.max(0,1 - elapsed/200)); }
  ctx.clearRect(0,0,W,H); drawBackground(dt); drawLane(); drawBarlines(songTime); ctx.save(); ctx.strokeStyle = 'rgba(200,200,200,0.5)'; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(judgementX, laneY, noteRadius+10, 0, Math.PI*2); ctx.stroke(); ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(judgementX, laneY, noteRadius, 0, Math.PI*2); ctx.stroke(); ctx.restore(); drawNotes(songTime); drawOverlay(); drawFlying(songTime);
  for(const n of scheduledNotes){ if(!n.judged && !n.hit && (songTime - n.timeMs) > lateWindow){ n.judged = true; n.hit = true; combo = 0; score = Math.max(0, score-50); updateScoreDisplay(); animateCombo(); triggerRectOnMiss(); flashOutline('miss'); } }
  scheduledNotes = scheduledNotes.filter(n => { if(n.judged) return false; if(n.hit && n.hitTime!=null && (songTime - n.hitTime) > 1600) return false; if((songTime - n.timeMs) > lookaheadMs) return false; return true; }); requestAnimationFrame(gameLoop); }

const overlayState = {leftSurface:false,leftRim:false,rightSurface:false,rightRim:false};
const overlayRect = {depressed:false,vibeScale:1,lastVibe:0};
function pressOverlay(side){ if(side==='don-left'){ overlayState.leftSurface=true; setTimeout(()=>overlayState.leftSurface=false,140);} if(side==='ka-left'){ overlayState.leftRim=true; setTimeout(()=>overlayState.leftRim=false,140);} if(side==='don-right'){ overlayState.rightSurface=true; setTimeout(()=>overlayState.rightSurface=false,140);} if(side==='ka-right'){ overlayState.rightRim=true; setTimeout(()=>overlayState.rightRim=false,140);} }
function triggerRectOnMiss(){ overlayRect.depressed=true; setTimeout(()=>overlayRect.depressed=false,300);} function triggerRectOnHit(){ overlayRect.vibeScale=1.18; overlayRect.lastVibe=performance.now(); }
function triggerOverlayGlow(info){ overlayGlow.type = info.type; overlayGlow.side = info.side; overlayGlow.ts = performance.now(); }
let overlayGlow = {type:null, side:null, ts:0, dur:320};

window.addEventListener('resize', ()=>{ W = canvas.width = canvas.clientWidth || 1000; H = canvas.height = canvas.clientHeight || 520; overlayRight = judgementX - 60; overlayWidth = overlayRight - overlayLeft; padWidth = W / padCount; drumCenterX = overlayRight - 60; drumRimOuter = drumR + 24; drumCenterY = laneY; drumR = Math.max(40, Math.min(80, Math.round(W*0.052))); padHeight = Math.max(96, Math.round(H*0.22)); semiCenterX = W/2; semiRadius = W * 0.6; });

updateScoreDisplay(); requestAnimationFrame(gameLoop);
</script>
</body>
</html>
